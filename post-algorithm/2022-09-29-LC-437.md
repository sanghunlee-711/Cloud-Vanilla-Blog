---
slug: 2022-09-29-LC-437
title: LC#437 (Path Sum III)
author: Sanghun lee
date: 2022-09-29 11:33:00 +0800
categories: [LeetCode, DFS, Prefix]
folder: [post-algorithm]
tags: [Algorithm]
math: true
mermaid: true
image:
  src: https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/LeetCode_Logo_black_with_text.svg/640px-LeetCode_Logo_black_with_text.svg.png
  width: 850
  height: 585
---

# 문제

Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).
Example 1

```md
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
```

Example 2

```md
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
```

Constraints:

The number of nodes in the tree is in the range [0, 1000].
-109 <= Node.val <= 109
-1000 <= targetSum <= 1000

# 풀이

누가봐도 DFS문제라 제일 쉬운 방법부터 시작했다.
우선 중위탐색으로 위에서부터 모든 노드들을 탐색하되 현재 노드에서 부터 그 아래로의 subNodes들의 모든합을 구해서 targetSum과 동일한지
모든 케이스를 확인해주는 방식으로 말이다.

## pseudo

1. In Order DFS를 실행한다
2. 현재 노드에서부터 하위노드들의 모든 합을 더해서 타겟과 동일한지 확인하는 함수를 매 탐색시 불러준다.

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number}
 */
/*
DFS문제인데 여기에 이진탐색 힌트가 있네 ㅎㅅㅎ..
우선 위에서 부터 아래로 inorder로 탐색하면서 매 케이스에서 합이 올바른지 확인하는 방법이 필요함
*/
var pathSum = function (root, targetSum) {
  const stack = [root];
  let count = 0;

  const checkSum = (node, sum) => {
    if (!node) return;

    sum += node.val;
    if (sum === targetSum) count++;
    return checkSum(node.left, sum) || checkSum(node.right, sum);
  };

  while (stack.length) {
    const curr = stack.pop();
    if (!curr) return count;
    if (curr.right) stack.push(curr.right);
    checkSum(curr, 0);
    if (curr.left) stack.push(curr.left);
  }

  return count;
};
```

## 다른풀이 - 1

Recursive가 아닌 Iterative방식으로 진행해보고 싶어서 코드를 바꿔보았다.

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number}
 */
var pathSum = function (root, targetSum) {
  const stack = [root];

  let count = 0;

  const checkSumFromThisNode = (node) => {
    let sum = 0;
    let subStack = [node];

    while (subStack.length) {
      let subCurr = subStack.pop();
      sum += subCurr.val;
      if (sum === targetSum) count++;

      if (subCurr.right) subStack.push(subCurr.right);
      if (subCurr.left) subStack.push(subCurr.left);
    }
  };

  // DFS in order way
  while (stack.length) {
    let curr = stack.pop();
    if (!curr) return count;
    if (curr.right) stack.push(curr.right);
    //find total sum in down way again
    checkSumFromThisNode(curr);
    if (curr.left) stack.push(curr.left);
  }

  return count;
};
```

## 다른풀이 - 2

재귀를 통해 모든케이스를 찾으면 중복되는 subProblem이 이문제에서 굉장히 많기 때문에 메모이제이션을 통해
DP방식으로 이미 풀린 하위문제를 재 활용하는 방식으로 진행.

DFS로 접근한다고 하면 첫번째 1로가서 1이 포함된 가장 큰 정사각형을 찾기 위해 인접셀이 시작할 수 있는 가장 큰 사각형의 사이즈를 찾으려고 계속 반복을 할 것 임.

모든 1에 대해서 진행한 뒤 가장 큰 사각형의 1 + 최소값이 넓이가 되는것을 알 수가 있게 됨.

dfs로 접근하면 모든 subProblem을 카운팅하여 돌아가는 케이스가 굉장히 많아짐.

그래서 DP를 통한 메모이제이션을 통해 상향식 접근(Tabulation)으로 이를 해결하는 것임.

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
/*
DFS로 접근시

일단 두개의 subset이 같기 위한 전제는
total의 값이 subSum의 값의 두배가 되어야함
total을 2로 나눴는데 나눠지지 않는 Odd케이스면 답에 충족이 안됨.

dfs recursive를 활용해서 모든케이스를 다 계산해보면 답이 나올 것임.

이렇게 모든케이스를 검사할때 subProblem이 계속 중첩되는 것을 확인할 수 있으므로 메모이제이션을 이용해서 부분문제합의 연산을 줄여보자!

T.C:(O(M*N))
Bottom up  DP version
*/
var canPartition = function (nums) {
  let total = nums.reduce((a, b) => a + b);

  if (total % 2 !== 0) return false;

  let subSum = total / 2,
    n = nums.length;
  //dp[n][subSum];
  let dp = new Array(n + 1)
    .fill(0)
    .map((el) => (el = new Array(subSum + 1).fill(false)));
  dp[0][0] = true; //합이 0 이고 길이가 0 일때이니까

  for (let i = 1; i <= n; i++) {
    let curr = nums[i - 1];

    for (let tempSum = 0; tempSum <= subSum; tempSum++) {
      // Sum can be formed excluding ith element
      if (tempSum < curr) dp[i][tempSum] = dp[i - 1][tempSum];
      // Sum can be formed including ith element
      else dp[i][tempSum] = dp[i - 1][tempSum] || dp[i - 1][tempSum - curr];
    }
  }
  return dp[n][subSum];
};
```

# 3. 결론

항상 기억하자 BruteForce로 접근해보고 전체 subProblem을 원하는 것 같다? -> DFS를 고려해보자. 그런데 부분문제합이 겹치는 것 같다? -> 상향식 메모이제이션(DP)를 고려해보자 -> 최적화가 필요하다? -> 하향식 메모이제이션을 진행해보자

## 참고

- [LeetCode - 416. Partition Equal Subset Sum](https://leetcode.com/submissions/detail/811018722/)
