---
slug: 2022-10-24-LC-151
title: LC#209 (Reverse Words in a String)
author: Sanghun lee
preview: LC#209 (Reverse Words in a String)
date: 2022-10-24 11:33:00 +0800
categories: [LeetCode, Array, String]
folder: [post-algorithm]
tags: [Algorithm]
math: true
mermaid: true
image:
  src: https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/LeetCode_Logo_black_with_text.svg/640px-LeetCode_Logo_black_with_text.svg.png
  width: 850
  height: 585
---

# 문제

Given an input string s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.

Return a string of the words in reverse order concatenated by a single space.

Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

Example 1

```md
Input: s = "the sky is blue"
Output: "blue is sky the"
```

Example 2

```md
Input: s = " hello world "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

Example 3

```md
Input: s = "a good example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

Constraints:

1 <= s.length <= 104
s contains English letters (upper-case and lower-case), digits, and spaces ' '.
There is at least one word in s.

Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?

# 풀이

미디엄문제인데... 아마도 Follow-up방식으로 풀면 미디엄이 적합한 문제인 것 같다.
간단한게 메서드를 활용해서 풀었다.

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function (s) {
  return s
    .split(' ')
    .filter((el) => el !== '')
    .reverse()
    .join(' ');
};
```

## 다른 풀이 - 1

매 루프안에 윈도우를 만들어 윈도우 내에서 minCount를 업데이트 시켜주며 최소값을 찾는 방식이다
이또한 윈도우의 길이가 기하급수적으로 커지면 O(N\*\*2) 을 가질 수 있으나 제약조건에서 요소들의 값이 무조건 양수이기에 대부분 O(N)으로 잡힐 것이다.

```javascript
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */

var minSubArrayLen = function (target, nums) {
  let minCount = Infinity;
  let left = 0,
    sum = 0;

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];

    while (sum >= target) {
      minCount = Math.min(minCount, i + 1 - left);
      sum -= nums[left];
      left++;
    }
  }
  return minCount === Infinity ? 0 : minCount;
};
```

## 다른풀이 - 2

합배열의 해당 인덱스의 값은 합배열의 그전 인덱스의 값 + 그전인덱스의 요소를 더한 값
즉, `sums[i] = sums[i-1] + nums[i-1]` 를 활용한 풀이 방법이다.
해당 전제조건을 가진 뒤 sums를 구축해놓으면 원하는 인덱스를 가져오기 위해 이진 탐색을 통해 sums배열을 돌려보면 `다른풀이-1`에서 `i`의 값을 얻어 낼 수 있게 되는 것이다.

```javascript
const lowerBound = (list, target, start = 0, end = list.length) => {
  let l = start,
    r = end;

  while (l < r) {
    let mid = Math.floor((l + r) / 2);
    if (list[mid] < target) l = mid + 1;
    else r = mid;
  }
  return l;
};

var minSubArrayLen = function (target, nums) {
  const len = nums.length,
    sums = [0];
  let minCount = Infinity;

  for (let i = 1; i <= len; i++) sums[i] = sums[i - 1] + nums[i - 1];

  for (let i = 0; i < len; i++) {
    let sum = target + sums[i],
      k = lowerBound(sums, sum);

    if (k <= len) minCount = Math.min(minCount, k - i);
  }

  return minCount === Infinity ? 0 : minCount;
};
```

# 3. 결론

다양한 방식들을 다시 복습할 수 있는 좋은 기회였다.

## 참고

- [LeetCode - 209.Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/2716609/JS-Binary-Search-Sliding-Window-two-pointers-with-few-comment)
