---
slug: 2023-10-12-core-js
title: Book comment - 오브젝트 (코드로 이해하는 객체지향 설계)
summary: 다시한번 읽어보자
author: Sanghun lee
date: 2023-10-12 11:33:00 +0800
categories: [Career]
folder: [post-personnel]
tags: [Career]
math: true
mermaid: true
image:
  src: ''
  height: 585
---

# 작성 이유 ?

2020년 10월 23일에 처음 읽은 기록이 있는 책이다. 당시에 막 개발에 발을 디디는 시점이었던 것 같은데.. 얼마나 머리속에 관련 정보가 많이 있는지에 대한 확인과 빈 정보는 채워넣고 다시 한번 보았을때 금방 기억이 날 수 있도록 메모를 하기 위해 작성해본다.

---

# 1. 데이터 타입

## 1.1 데이터 타입의 종류

- 일반적으로 기본형은 할당이나 연산시 복제되고 참조형은 참조된다고 알려져 있습니다.
- 다만 기본형은 값이 담긴 주솟값을 바로 복제하는 반면 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다는 점이 다릅니다.

```md
- 기본형: Number, String, Boolean, null, undefined, symbol
- 참조형: Object (객체 하위분류들) >> Array, Function, Date, RegExp, Map, WeekMap, Set, WeakSet
```

## 1.2 데이터 타입에 관한 배경 지식

- 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 비트(Bit)라고 합니다. 1바이트는 8개의 비트로 구성되어 있습니다.
- 메모리는 매우 많은 비트들로 구성되어있는데, 각 비트는 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있습니다.
- 한편 메모리 용량이 과거보다 월등히 커진 상황에서 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로워 졌습니다. 그래서 메모리 공간을 좀 더 넉넉하게 할당했습니다. 숫자의 경우 ... 8바이트를 확보합니다.

- 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리주솟값**을통해 서로 구분하고 연결할 수 있습니다.
- 변수는 변할 수 있는 수 입니다. ... 컴퓨터용어로 쓸 때는 변할 수 있는 무언가로 확장시켰습니다. 여기서 무언가란 데이터를 말합니다. **식별자**는 어떤 데이터를 식별하는데 사용하는 이름 즉 **변수명**입니다.

## 1.3 변수 선언과 데이터 할당

- 이 후에 사용자가 a(식별자)에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환할 것 입니다.

- 데이터를 저장하기 위한 별도의 메모리공간을 다시 확보해서 문자열 'abc'를 저장하고, 그 주소를 변수영역에 저장하는 식으로 이뤄집니다.
- 왜 변수영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 더 거치는걸까요? 이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과입니다.
- 이처럼 변수 영역과 데이터 영역을 분리하면 데이터 대한 처리 효율이 높아집니다.

## 1.4 기본형 데이터와 참조형 데이터

- 이것이 바로 불변값의 성질입니다. 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않습니다.
- 기본형 데이터와의 차이는 '객체의 변수(프로퍼티 영역)'이 별도로 존재한다는 점입니다. 변수에는 다른값을 얼마든지 대입할 수 있습니다. 바로 이 부분 때문에 흔히 참조형 데이터는 가변이라고 하는 것이죠.
- 참조카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됩니다. 가비지 컬렉터는 런타임 환경에 따라 특정시점이나 메모리사용량이 포화상태에 임박할 때마다 자동으로 수거 대상들을 수거합니다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 됩니다.

- 책에서 기본형은 값을 복사하고 참조형은 주소값을 복사해야하기 때문에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없습니다. 다만 기본형은 주솟값을 복사하는 과정이 한번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있습니다.

## 1.5 불변 객체

- 참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립합니다. 데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 **기존 데이터는 변하지 않습니다**

- 이런 방식보다는 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수를 만드는 편이 더 좋을 것입니다.(불변성 유지를 위한 얕은 복사)

```javascript
const copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

- 얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.

- 그러니까 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할때, 객체의 프로퍼티 중에서 그 값이 **기본형 데이터일 경우에는 그대로 복사**하면 되지만 **참조형 데이터는 다시 그 내부의 프로퍼티들을 복사**해야 합니다.
  이 과정을 참조형 데이터가 있을 때 마다 재귀적으로 수행해야만 비로소 깊은 복사가 되는 것이죠.

```javascript
const copyDeepObject = function (target) {
  var result = {};
  //typeof null도 obejct가 반환되어 조건에 들어감
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) {
      result[prop] = copyDeepObject(target[prop]);
    }
  } else {
    result = target;
  }

  return result;
};
```

- 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 겁니다. 이방법은 단순함에도 불구하고 잘 동작합니다. 다만 메서드나 숨겨진 프로퍼티 proto, getter/setter등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시합니다.

## 1.6 undefined와 null

- 자바스크립트 엔진은 사용자가 응당 어떤값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환합니다.

  - 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
  - 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
  - return 문이 없거나 호출되지 않는 함수의 실행결과

- '비어있는 요소'와 'undefined'를 할당한 요소는 출력결과부터 다릅니다.

- 사실은 배열도 객체임을 생각해보면 지극히 자연스러운 현상입니다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없는 것이 당연하죠. 배열은 무조건 length프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정할 것이라고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 **인덱스 값을 지정할 때 비로소 빈공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는등의 동작**을 합니다. 즉, 값이 지정되지 않은 인덱스는 아직은 존재하지 않는 프로퍼티에 지나지 않는 것입니다.

- 같은 의미를 가진 null이라는 값이 별도로 있는데 굳이 undefined를 써야할 이유가 없습니다. 비어있음을 명시적으로 나타내고 싶을때는 undefined가 아닌 null을 쓰면 됩니다. null은 애초에 이런 용도로 만든 데이터 타입입니다. 이런 규칙을 따르는 한 undefined는 오직 값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값으로서만 존재할 수 있겠죠.

## 1장 정리

- 자바스크립트 데이터 타입에는 기본형과 참조형이 존재한다.

  - 기본적으로 기본형이 불변값, 참조형이 가변값

- 변수는 변경가능 데이터가 담길 수 있는 공간을 말한다
- 식별자는 그 변수의 이름을 말한다.

- 참조형 데이터 할당의 경우 내부 프로퍼티를 위한 변수 영역 별도 확보하여 확보된 주소를 변수에 연결하고 변수영역에 각 프로퍼티의 식별자를 저장하고, 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다. 참조형 데이터가 여러개의 프로퍼티(변수)들을 모은 그룹이기 때문에 이런 차이가 발생한다.

- 이 차이로 인해 참조형 데이터를 가변값으로 여기는 상황이 생긴다. 그럼에도 불변값으로 사용하는 방법은 재귀를 통한 함수 작성 또는 JSON을통한 복사 또는 한단계 아래의 변수만 복사하는 얕은복사(spread operator등..)이 있다.

- Undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 없음을 표현하기위해 대입한 값이다.

## 2. 실행 컨텍스트 (Execution context)

- 실행 컨텍스트는 실행할 코드에 제공할 환경정보들을 모아놓은 객체로, 자바스크립트의 동적언어로서의 성격을 가장 잘 파악할 수 있는 개념이다.

- 자바스크립트는 어떤 실행 컨텍스트가 활성화 되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경정보를 구성하고, this값을 설정하는 등의 동작을 수행하는데, 클로저를 지원하는 대부분의 언어에서 이와 유사하거나 동일한 개념이 적용되어 있다.

## 2.1 실행 컨텍스트란?

- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경정보들을 모아 컨텍스트를 구성하고, 이를 콜스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.
  - 여기서 동일한 환경, 즉 하나의 실행컨텍스트를 구성할 수 있는 방법으로는 전역공간, eval함수, 함수가 있는데 우리가 흔히 실행컨텍스트를 구성하는 방법은 함수를 실행하는 것 뿐이다. **(ES6에서는 객체 블록에 의해서도 생성된다)**

```javascript
var a = 1; // --- (1)

function outer() {
  function inner() {
    console.log(a); //undefined
    var a = 3;
  }
  inner(); // --- (2)
  console.log(a); // 1
}

outer(); // --- (3)
console.log(a); // 1
```

- 처음 자바스크립트를 실행시키는 순간(1)에 전역컨텍스트가 콜스택에 담긴다. ...자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다고 이해하면 된다.

- (3)에서 outer함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경정보를 수집해서 outer 실행컨텍스트를 생성한 후 콜스택에 담는다. 따라서 현재 콜스택 맨 위에는 outer실행컨텍스트가 있다. 따라서 전역컨텍스트와 관련된 코드의 실행 중단 후 outer 실행컨텍스트와 관련된 코드(즉, outer함수 내부의 코드들)를 순차적으로 실행한다.

- 다시 (2)에서 inner함수의 실행컨텍스트가 콜스택의 가장 위에 담기면 outer컨텍스트와 관련된 코드의 실행을 중단하고 inner함수 내부의 코드를 순서대로 진행할 것이다.

- inner 함수 내부에서 a에 3을 할당하고 함수가 종료되어 다시 outer함수의 실행컨텍스트가 가장 위에 있다. 따라서 a변수 값을 출력하고 outer함수의 실행컨텍스트도 콜스택에서 사라지게된다. 마지막으로 outer함수 호출 부 아래의 console을 실행시키고 전역 공간에 더는 실행할 코드가 남지 않아 전역컨텍스트도 제고된 뒤 아무것도 콜스택에 남지않고 종료된다.

- 스택 구조를 잘 생각해보면 실행컨텍스트가 콜스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다.

- 실행컨텍스트 객체에는 자바스크립트 엔진이 활용할 목적으로 생설할 뿐 개발자가 코드를 통해 확인할 수 없는 정보들을 저장해놓는다.
  - Variable Environment: 현재 컨텍스트내의 식별자들에 대한 정보, 외부 환경정보, 선언 시점의 Lexical Environment의 스탭샷으로, 변경사항은 반영되지 않는다
  - Lexical Environment: 처음에는 Variable Environment와 같지만 변경사항이 실시간 반영된다.
  - ThisBinding: this 식별자가 바라봐야할 대상 객체

```md
<!-- |제목|내용|설명|
|:---|---:|:---:| -->

|inner|Variable Environment|environmentRecord(snapshot), outerEnvironmentReference(snapshot)|
|inner|Lexical Environment|environmentRecord, outerEnvironmentReference|
|inner|ThisBinding| 중앙정렬|
|outer|||
|전역컨텍스트||
```

## 2.2 Variable Environment

- Variable Environment 에 담기는 내용은 Lexical Environment에 담기는 내용과 같지만 최초 실행시의 스냅샷을 유지한다는점이 다르다.
- 실행컨텍스트 생성할 때 Variable Environment에 정보를 먼저 담은다음, 이를 그대로 복사해서 Lexical Environment를 만들고 이후에는 Lexical Environment를 주로 활용하게 된다.

## 2.3 Lexical Environment

### environment Record와 호이스팅

- environment Record에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
- 컨텍스트를 구성하는
  - 함수에 지정된 매개변수 식별자
  - 선언한 함수가 있는경우 함수 자체
  - var로 선언된 변수의 식별자등이 식별자에 해당한다.
- 처음부터 끝까지 쭉 훑으며 순서대로 수집한다.

- 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당환경에 속한 코드의 변수명을 모두 알고 있게 되는 셈이다.
- 호이스팅이란 끌어올리다라는 의미의..., 변수정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념이다. 자바스크립트 엔진이 실제로 끌어올리지는 않으나 끌어올린 것으로 간주하는 것이다.

### 스코프 , 스코프체인, outer Environment Reference

- 스코프란 식별자의 유효범위다.

  - ES5까지는 특이하게도 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생성된다.
  - ES6에서는 블록에 의해서도 스코프 경계가 발생하게 함으로써 다른언어와 비슷해짐. let, const, class, strict mode에서의 함수선언 등에 대해서만 범위로서의 역할을 수행한다. ES6에서는 둘을 구분하기 위해 함수 스코프, 블록 스코프라는 용어를 사용한다.

- 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다. 이를 가능케 하는 것이 Lexical Environment의 두번째 수집자료인 outer Environment Reference이다.

- 이처럼 outer Environment Reference는 연결리스트 형태를 띱니다. 선언 시점의 Lexical Environment를 계속 찾아 올라가면 마지막엔 전역컨텍스트의 Lexical Environment가 있을 것이다.

- 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에게만 접근가능하게 된다.

- 즉 inner함수 내부에서 a변수를 선언했기 때문에 전역공간에서 선언한 동일한 이름의 a변수에는 접근할 수 없는셈이다. 이를 **변수 은닉화** 라고한다.

- 즉, 전역공간에서 선언한 변수는 전역변수이고 함수 내부에서 선언한 변수는 무조건 지역변수입니다.

## 2장 정리

- 실행컨텍스트는 실행할 코드에 제공될 환경정보를 모아놓은 객체이다.

  - 실행컨텍스트는 전역공간에서 자동으로 생성되는 전역컨텍스트와 eval, 함수 실행에 의한 컨텍스트 등이 있다.
  - 실행컨텍스트가 *활성화*되는 시점에 Variable Envrionment, Lexical Environment, This Binding 세가지 정보를 수집한다.

  - 실행 컨텍스트 생성시에는 Variable Envrionment, Lexical Environment가 동일하나 Lexical Environment은 함수 실행 도중 변경사항이 반영된다.
  - Lexical Environment의 environmentRecord는 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집한다.
  - Lexical Environment의 outerEnvironment Reference는 바로 직전 컨텍스트의 Lexcial Environment 정보를 참조한다.

- 호이스팅은 Lexical Environment의 environmentRecord가 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집하는 과정을 추상화한 개념으로 실행컨텍스트가 관여하는 코드집단의 최상단으로 이들을 끌어올린다고 해석하는 것이다.

  - 변수선언과 값할당이 동시에 이뤄진 문장은 선언부만을 호이스팅하고 할당과정은 원래자리에 남아있게 된다.
  - 여기에서 함수 선언문과 함수 표현식의 차이가 발생한다(표현식이 익명함수 변수에 할당하는 방식)

- 스코프는 변수의 유효범위이다.
  - outerEnvironment Reference는 해당 함수가 선언된 위치의 Lexcial Environment 정보를 참조한다.
  - 코드 상에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 Lexcial Environment를 탐색하고 발견하지 못할 경우 다시 outerEnvironment Reference에 담긴 Lexical Environment를 탐색하는 과정을 거친다. 전역 Lexical Environment까지 탐색해도 못찾는 경우 undefined를 반환한다.

# 3. this

- 다른 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 클래스에서만 사용할 수 있기 때문에 혼란의 여지가 없거나 많지 않다. 그러나 자바스크립트에서의 this는 어디서든 사용할 수 있다.

- 함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능입니다.

## 3.1 상황에 따라 달라지는 this

- 자바스크립트에서 **this는 기본적으로 실행컨텍스트가 생성될 때 함께 결정**된다.
  - 실행컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 **this는 함수를 호출할 때 결정된다**.

### 전역공간에서의 this

- 전역공간에서 this는 전역객체를 가리킵니다. 개념상 전역컨텍스트를 생성하는 주체가 바로 전역객체이기 때문입니다.
- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당합니다. 변수이면서 객체의 프로퍼티이기도 한 셈이죠.

- ...자바스크립트의 모든 변수는 실은 특정객체의 프로퍼티로서 동작하기 때문입니다.
- 특정객체란 바로 실행컨텍스트의 Lexical Environment입니다. 실행 컨텍스트는 변수를 수집해서 Lexical Environment의 프로퍼티로 저장합니다. 이 후 어떤 변수를 호출하면 Lexical Environment를 조회해서 일치하는 프로퍼티가 있을경우 그값을 반환한다.
- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.

- 이처럼 var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable여부에서 차이를 보입니다
  - window.a 로 선언하는 경우 delete window.a 로 삭제가능
  - var a 로 선언 뒤 할당하는 경우 삭제 delete window.a로 삭제 불가능

### 메서드로서 호출할 때 그 메서드 내부에서의 this

- 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.
- 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출한 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.

- this에는 호출한 주체에 대한 정보가 담깁니다. 어떤함수를 메서드로서 호출하는 경우 호출주체는 바로 함수명 앞의 객체입니다.

- 함수로서 호출할 경우에는 this가 지정되지 않습니다. 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 직접관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없는 것입니다. ... 함수에서의 this는 미정이므로 전역객체를 가리키게 됩니다. 더글라스 크락포드는 이를 명백한설계상의 오류라고 지적합니다.

- 그러니까 this바인딩에 관해서는 함수를 실행하는 당시의 주변환경(메서드 내부인지, 함수 내부인지)은 중요하지 않고, 오직 해당함수를 호출하는 구문앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것입니다.

- 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠습니다.
- 그 대표적인 방법은 바로 변수를 활용하는 것입니다(var self = this)

- ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, **this를 바인딩하지 않는 화살표 함수(Arrow Function)를 새로 도입했습니다. 화살표 함수는 실행컨텍스트를 생성할 때 this바인딩 과정 자체가 빠지게 되어**, 상위스코프의 this를 그대로 활용할 수 있습니다.

- 콜백함수에서의 this는 무조건 이거다라고 정의할 수 없으며 콜백함수의 제어권을 가지는 함수가 콜백함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

## 2.2 명시적 this를 바인딩 하는 방법

- call메서드는 메서드의 호출주체인 함수를 즉시실행하도록 하는 명령입니다. call메서드의 첫번째 인자를 this로 바인딩하고 이후의 인자들을 호출할 함수의 매개변수로 합니다.

- apply메서드는 메서드는 call메서드와 기능적으로 완전 동일하며 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점만 차이가 있다.

- bind메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.즉 bind메서드는 함수에 this를 미리 적용하는 것과 부분적용함수를 구현하는 두가지 목적을 모두 지닙니다.
  - name프로퍼티에 동사 bind의 수동태인 bound라는 접두어가 붙는다는 점입니다.

```javascript
var func = function (a, b, c) {
  console.log(this, a, b, c);
};

func.call({ x: 1 }, 4, 5, 6); // {x:1} 4,5,6
func.call({ x: 1 }, [4, 5, 6]); // {x:1} 4,5,6
const bindFn = fun.bind({ x: 1 });
bindFn(4, 5, 6); // {x:1} 4,5,6

const bindFn2 = fun.bind({ x: 1 }, 4);
bindFn2(5, 7); // {x:1} 4,5,7
```

- ES6에서 도입된 화살표 함수는 실행컨텍스트 생성 시 this를 바인딩하는 과정이 제외되었습니다. 즉 이 함수 내부에는 this가 아예 없으며, 접근하고자하면 스코프체인 상 가장 가까운 this에 접근하게 됩니다.

## 3장 정리

- 명시적 this바인딩이 없는 한 늘 성립하는 경우

  - 전역공간에서의 this는 전역객체를 참조한다.
  - 어떤 함수를 메서드로서 호출 한경우 this는 메서드 호출주체(메서드 명 앞의 객체)를 참조한다.
  - 어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조한다. 메서드의 내부함수에서도 똑같다(이게 문제가 많이된다)
  - 콜백함수 내부에서의 this는 해당 콜백함수의 제어권을 넘겨받은 함수가 정의한바에 따르며, 정의하지 않은 경우 전역객체를 참조한다.
  - 생성자 함수에서의 this는 생성될 인스턴스를 참조한다.

- 명시적 this바인딩 경우
  - call, apply메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출한다.
  - bind메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다

# 4. 콜백 함수

- 그러니까 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐입니다. 이 차이를 정확히 이해하는 것이 중요합니다.

```javascript
var obj = {
  vals: [1, 2, 3],
  logValues: function (v, i) {
    console.log(this, v, i);
  },
};

obj.logValues(1, 2); //{ vals:[1,2,3], logValues:f} 1 2
[(4, 5, 6)].forEach(obj.logValues); // window {...} 4 0 --> obj의 메서드를 함수로 넘긴것임을 인지하자.
// window {...} 5 1
// window {...} 6 2
```

- ES5에서 등장한 bind메서드를 이용하면 아쉬움을 보완할 수 있다.

```javascript
var obj = {
  vals: [1, 2, 3],
  logValues: function (v, i) {
    console.log(this, v, i);
  },
};

obj.logValues(1, 2); //{ vals:[1,2,3], logValues:f} 1 2
[(4, 5, 6)].forEach(obj.logValues.bind(obj)); // { vals:[1,2,3], logValues:f} 4 0 --> obj를 this로 바운드 시켰다.
// window {...} 5 1
// window {...} 6 2
```

## 콜백지옥과 비동기 제어

- CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드입니다. ...별도의 요청, 실행 대기(addEventListener), 보류(setTimeout)등과 관련된 코드는 비동기적인 코드입니다.

- 지난 십수년간 자바스크립트 진영은 비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것 처럼 보이게끔 처리해주는 장치를 마련하고자 끊임없이 노력해 왔습니다. ES6에서는 Promise, Generator등이 도입되었고 ES2017에서는 async/awiat가 도입되었습니다.
  - Promise는 비동기 작업이 완료될 때 비로소 resolve또는 reject를 호출하는 방법으로 비동기작업의 동기적 표현이 가능합니다.
  - Generator함수 실행 시 Iterator가 반환되고, next메서드를 통해 내부에서 가장 먼저 등장하는 yield에서 함수의 실행을 멈춘다. 따라서 비동기 작업이 완료되는 시점마다 next메서드를 호출해준다면 순차적 진행이 가능하다
  - asny/await는 비동기 작업을 수행하고자 하는 함수앞에 async 키워드를 달고 await 키워드 뒤의 내용을 Promise로 자동전환하고, 해당내용이 resolve된 후에야 다음으로 진행하도록 만든다.

# 5. 클로저

- 클로저는 여러 함수형 프로그래밍언어에서 등장하는 보편적인 특성입니다.
- A closure is the combination of a function and the lexical environment(outer Environment Reference) within which that function was declared.
- 가비지 컬렉터에는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집대상에 포함시키지 않습니다.
- 클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달하는 경우 A의 실행컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상을 말한다.
  - 간단하게 말해 지역변수를 참조하는 내부함수를 외부에 전달하는 경우 클로저 중 하나의 케이스가 된다.

## 5.2 클로저와 메모리 관리

- 메모리 누수의 위험을 이유로 클로저 사용을 조심해야한다거나 심지어 지양해야 한다고 주장하는사람들도 있지만 메모리 소모는 클로저의 본질적인 특성일 뿐이다.

- 클로저는 어떤필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생한다.
- 참고 카운트를 0으로 만드는 방법은? 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 된다.

```javascript
(
  function(){
    var a = 0;
    var intervalId = null;
    var inner = function () {
      if(++a >= 10) {
        clearInterval(intervalId);
        inner = null // inner식별자의 함수 참조를 끊어버림
      }
      console.log(a);
    }
  }
  intervalId = setInterval(inner, 1000);
)()

```

## 5.3 클로저 활용사례

- 콜백 함수내부에서 외부데이터를 사용하고자 할 때
- 접근권한 제어(정보은닉)
  - 함수에서 지역변수 및 내부 함수등을 생성한 뒤 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿인 경우 객체 또는 배열, 하나일 때는 함수)를 return한다.(return한 변수들은 공개 멤버가 되고, 그렇지 않은 변수들은 비공개 멤버가 된다.)
- 부분적용 함수

  - 디바운스, 디바운스는 짧은시간 동안 동일한 이벤트가 많이 발생할 경우 이를 전부 처리하지 않고 처음 또는 마지막에 발생한 이벤트에 대해 한번만 처리하는 것으로, 프론트엔드 성능최적화에 큰도움을 주는 기능 중 하나.

  ```javascript
  var debounce = function (eventName, func, wait) {
    var timeoutId = null;

    return function (event) {
      var self = this;
      console.log(eventName, 'event 발생');
      clearTimeout(timeoutId);
      timeoutId = setTimeout(func.bind(self, event), wait); //대기 시간이 경과하기 전 동일 이벤트 발생 시  clearTimeout에 의해 대기열을 초기화 하고 다시 새로운 대기열을 등록한다.  결국 각 이벤트가 바로 이전 이벤트로 부터 wait시간 이내에 발생하는 한 마지막에 발생한 이벤트만이 초기화되지 않고 무사히 실행되는 것이다.
    };
  };
  const clickTest = function (e) {
    console.log(e);
  };
  우;
  document.body.addEventListener('click', debounce('click', clickTest, 500));
  ```

  - PS. Symbol.for 메서드는 전역 심볼공간에 인자로 넘어온 문자열이 이미 있으면 해당값을 참조 그렇지 않으면 새로 만드는 방식으로 어디서든 접근가능하면서 유일무이한 상수를 만들고자 할 때 적합하다.

- 커링함수, 커링함수란 여러개의 인자를 받는함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출 될 수 있게 체인형태로 구성한 것을 말한다.
  - 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 하면 결국 마지막 인자가 넘어갈 때 까지 함수 실행을 미루는 셈이 된다. 이를 함수형 프로그래밍에서는 지연실행이라고 칭한다.
  - 리덕스의 미들웨어가 이렇다고 볼 수 있따
  ```javascript
  const thunk = (store) => (next) => (action) => {
    return typeof action === 'function'
      ? action(dispatch, store.getState)
      : next(action);
  };
  ```

# 6. 프로토 타입

- 자바스크립트는 프로토타입 기반 언어입니다. 클래스기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻습니다.
- `new Constructor(생성자 함수)` -> `instance`, `Contructor.prototype` -> `instance.__proto__`

- ... `__proto__` 가 생략가능한 프로퍼티이기 때문입니다. 원래부터 생략하도록 정의되어있습니다. 이 정의를 바탕으로 자바스크립트 전체구조가 구성되었다고 해도 과언이 아닙니다.
- new 연산자로 Constructor를 호출하면 instance가 만들어지는데, 이 instance의 생략가능한 프로퍼티인 `__proto__` 는 Constructor의 proptotype을 참조한다.

- 자바스크립트는 함수에 자동으로 객체인 prototype 프로퍼티를 생성해놓는데, 해당 함수를 생성자 함수로서 사용할 경우, 그로부터 생성된 인스턴스에는 숨겨진 프로퍼티인 `__proto__`가 자동으로 생성되며, 이 프로퍼티는 생성자 함수의 prototype를 참조한다. `__proto__` 프로퍼티는 생략가능하도록 구성되어 있기 때문에 생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 됩니다.

```javascript
var arr = [1, 2];
console.dir(arr); // 이 출력의 __proto__ 값이
console.dir(Array); // 이 출력의 prototype 프로퍼티의 값과 동일하다.
```

- 생성자 함수의 프로퍼티인 prototype 객체 내부에는 constructor라는 프로퍼티가 있습니다. 인스턴스의 `__proto__`객체 내부에도 마찬가지 입니다. 이 프로퍼티는 단어 그대로 원래의 생성자 함수(자기자신)를 참조 합니다. 인스턴스로부터 그 원형이 무엇인지를 알 수 있는 수단이기 때문입니다.
- constructor를 변경하더라도 참조하는 대상이 변경될 뿐 이미 만들어진 인스턴스의 원형이 바뀐다거나 데이터타입이 변하는 것은 아님을 알 수 있다.
- 비록 어떤 인스턴스로부터 생성자 정보를 알아내는 유일한수단인 constructor가 항상 안전하지는 않지만 오히려 그렇기 때문에 클래스 상속을 흉내 내는 등이 가능해진 측면도 있다.

## 6.2 프로토타입 체인

- 만약 인스턴스가 동일한 이름의 프로퍼티 또는 메서드를 가지고 있는상황이라면 어떨까? `__proto__`내에 있는 메서드가 아닌 본 객체에 있는 메서드가 호출된다.

  - 자바스크립트 엔진이 가장 가까운 대상인 자신의 프로퍼티를 검색하고 없으면 그 다음으로 가까운 대상인 `__proto__`를 검색하니 검색순서에 밀려 호출되지 않은 것이다.

- 어떤 데이터의 `__proto__` 프로퍼티 내부에 다시 `__proto__` ㅍ로퍼티가 연쇄적으로 이어지는 것을 **프로토타입 체인** 이라고 하며, 이 체인을 따라 검색하는 것을 **프로토타입 체이닝**이라고 한다.

- 객체 한정 메서드들을 Object.prototype이 아닌 Object에 직접 부여할 수 밖에 없었던 이유를 다시 강조하자면, Object.prototype이 여타의 참조형 데이터뿐 아니라 기본형 데이터조차 `__proto__`에 반복 접근함으로써 도달 할 수 있는 최상위 존재이기 때문입니다.

## 6장 정리

- 자바스크립트는 프로토타입 기반 언어입니다. 클래스기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻습니다. 따라서 프로토타입은 프로토타입 기반 언어에서 클래스기반의 상속과 비슷한 효과를 내기 위해 복제되는 객체의 원형이라고 할 수 있습니다.

- 어떤 생성자 함수를 new 연산자와 함께 호출한다면 Constructor(생성자함수)에 정의된 내용을 바탕으로 새로운 인스턴스가 생성됩니다. 이 인스턴스에는 `__proto__`라는 Constructor(생성자함수)의 prototype 프로퍼티를 참조하는 프로퍼티가 자동으로 부여됩니다. `__proto__`는 생략가능한 속성이라서, 인스턴스는 Contstructor.prototype의 메서드를 마치 자신의 메서드인 것 처럼 호출 할 수 있습니다.

- 생성자 함수의 constructor 프로퍼티는 자기 자신을 가리키게 되는데 이는 인스턴스가 자신의 생성자 함수가 무엇인지를 알고자할 때 필요한 수단이 됩니다.

- `__proto__`안에 다시 `__proto__`를 찾아가는 과정을 프로토타입 체이닝이라고 하며, 이 프로토타입 체이닝을 통해 각 프로토타입 메서드를 자신의 것처럼 호출 할 수 있습니다. 이 때 접근 방식은 자신으로부터 가장 가까운대상부터 먼 대상으로 나아가며, 원하는 값을 찾으면 검색을 중단합니다.

# 7. 클래스

- 다만 ES6의 클래스에서도 일정 부분은 프로토타입을 활용하고 있기 때문에, ES5체제 하에서 클래스를 흉내내기 위한 구현방식을 학습한느 것은 여전히 큰 의미가 있습니다.

## 7.1 클래스와 인스턴스의 개념이해

- 이 처럼 어떤 클래스의 속성을 지니는 실존하는 개체를 일컬어 인스턴스(instance)라고 합니다.

## 7.2. 자바스크립트의 클래스

- 그렇지만 프로토타입을 일반적인 의미에서의 클래스 관점에서 접근해보면 비슷하게 해석할 수 있는 요소가 없지 않습니다.

- 인스턴스에 상속되는지(인스턴스가 참조하는지) 엽에 따라 스태틱멤버와 인스턴스 멤버로 나뉩니다. 그런데 여너 클래스 기반 언어와 달리 자바스크립트에서는 인스턴스에더소 직접 메서드를 정의할 수 있기때문에 인스턴스메서드라는 명칭은 프로토 타입에 정의한 메서드를 지칭하는 것인지 인스턴스에 정의한 메서드를 지칭하는 것인지에 대해 도리어 혼란을 야기합니다. 따라서 이 명칭 대신에 자바스크립트의 특징을 살려 **프로토타입 메서드**라고 부르는 편이 더 좋을 것 입니다.

```javascript
var Rectangle = function(width, height) { //생성자
  this.width = width;
  this.height = height;
}

Rectangle.prototype.getArea = funciton () {
  return this.width * this.height; //(프로토타입) 메서드
}

Rectangle.isRectangle = function (instance) { //스태틱 메서드
  return instance instanceof Rectangle && instance.width > 0 && instance.height > 0;
}

var rect1 = new RecTangle(3,4);
console.lopg(rect1.getArea()) // 12
console.lopg(rect1.isRectangle()) // Error -> 상속 받을 프로토타입에 해당 값이 없으므로 인스턴스의 __proto__를 통해 프로토체이닝이 되지 않음.
console.lopg(Rectangle.isRectangle(rect1)) // true
```

## 7.3 클래스 상속

- SubClass.prototype에 SuperClass의 인스턴스를 할당한 다음 프로퍼티를 모두 삭제하는 방법

  ```javascript
  var Grade = function () {
    var args = Array.prototype.slice.call(arguments);

    for (var i = 0; i < args.length; i++) {
      this[i] = args[i];
    }

    this.length = args.length;
  };

  Grade.prototype = [];
  var g = new Grade(100, 80);

  g.push(90);
  console.log(g); //Grade{0:100, 1: 80, 2: 90,length:3}
  delete g.length;
  g.push(70);
  console.log(g); //Grade{0:70, 1:100, 2: 80, 3: 90,  ,length:1} // length속성을 삭제했으나 기존에 클래스 (Grade)에 있는 프로토타입 덕분에 삭제가 안됨
  ```

  - 클래스에 있는 값이 인스턴스의 동작에 영향을 줘서는 안되겠습니다.

- 빈 함수(Bridge)와 Object.freeze를 활용하는 방법
- Object.create를 활용하는 방법
- 이 세방법 모두 contructor프로퍼티가 원래의 생성자 함수를 바라보도록 조절이 필요하다.
