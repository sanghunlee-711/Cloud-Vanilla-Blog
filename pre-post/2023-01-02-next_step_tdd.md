---
slug: 2023-01-03-next-step-tdd
title: 넥스트스텝 스터디 참여후기(1~8주차)
summary: TDD, 클린코드에 조금 더 가까이!
author: Sanghun lee
date: 2023-01-03 11:33:00 +0800
categories: [TDD, Javascript, CleanCode]
folder: [post-personnel]
tags: [TDD]
math: true
mermaid: true
image:
  src: https://edu.nextstep.camp/resources/20220905052739/images/logo/logo_thumnail_white.jpg
  height: 585
---

# 1주차

## TDD란?

- 실패하는 테스트를 먼저 만들고 그 테스트를 통과하기위해 코드를 짜는 개발 방법
- 사고방식을 강조 함
- 제대로 동작하는지 빠르게 피드백을 받기위한 사고방식
- 결정과 피드백 사이의 갭에 대한 인식, 더 나아가 결정과 피드백 사이의 갭을 조절하기 위한 테크닉
- 결국은 내 결정이 잘 동작하는지 빠르게 피드백을 얻는것이 중요한 사고 방식이다.
- 따라서 테스트 코드는 의도치 않은 유용한 부산물이 된다..
- **TDD의 핵심은 피드백을 받는것**
- **더 빨리 더 자주 피드백을 받는 것!**
  - **더 자주 피드백을 받기 위해 작은영역으로 핵심을 포함한 가장 중요한 기능부터 문제를 쪼개서 접근해나가아면 좋음**

### TDD는 언제 하는 것이 좋은가?

- 여러번 구현해봐서 어떻게 해야할지 아는 경우는 굳이 할 필요가 없음.
- **처음 해봐서 막연한 경우, 요구사항이 변경될 수 있는 경우, 개발중에 코드가 많이 변경될 것 같은 경우**
- **내가 개발하고 나서 누가 유지보수 할 지 모르는 경우**
- **불확실성이 높은 상황일 수록 더 효과적이게 된다**

## 클린코드

1. 의도를 드러내는 네이밍 결과로 바로가는 것은 어렵다
   1. 좀 더 그 의도를 드러내는 **과정**에 **집중해보는 것이 좋다.**
      1. 의도를 드러내고(reveal the intention)
      2. 구현은 숨기고 (hide the implementation)
      3. 반환타입에 대한 명확한 힌트를 제공한다. (give a clear hint as to the expected return type)
   2. EX) linearSearchFor → searchFor → includes
   3. EX) getLinearSearchPosition → getSearchPosition → indexOf

### 이런 강의 자료를 어떻게 찾았을까?

엔지니어링 덕질을 해보자

추천하는 엔지니어들은 켄트백, 워드 커닝햄 등 고전이 되는 유명한 엔지니어이다.

이들의 책이나 내용이 공감되는 부분이 있을 때 그 부분들을 분석하고 거기서 파생되는 지식과 자료들을 찾아보며 공부하게 되었다고 한다.

## 개인 소감

이런 자료들을 찾아서 양질의 컨텐츠를 교육해주는것이 대단하다고 생각 되었다.

테스트코드를 혼자서 이 자료 저 자료 혼재해가며 열심히 공부하다가 드디어 개념부터하여 양질의 지식들을 제대로 배울 수 있는 기회가 생긴 것 같아 너무 기뻤다.

여기서 잘 배워서 개인블로그, 프로젝트, 회사에 까지 모든 코드들을 테스트를 도입하여 맘 편히 리팩토링 할 수 있게 되면 좋겠다 😅.

## 참고하면 좋을 것 들

- [워드 커닝햄 변수명 짓기](https://wiki.c2.com/?IntentionRevealingNames)

- [PPT](https://docs.google.com/presentation/d/18c4kP9oWbGvKOeX7hd6Tt9FDSWx0NRomdqxQpeUFeto/edit#slide=id.g11a196697e6_0_119)

## 1주차 온보딩 계산기 미션!

나의 온보딩 계산기 미션 참여기!
[[클린코드 4기 이상훈] 계산기 구현](https://github.com/next-step/js-calculator/pull/144)

# 2주차

## 효율적인 공부방법!

- 흰색지대 : 적용하고 무슨 내용인지 안다 (2)
- 회색지대: 들어봤고 알고는 있는데 내가 잘쓰지 못하는 것 같다 (1)
- 검은색지대: 감도 안잡힌다 (0)

회색지대 → 흰색지대부터 먼저 진행해보면 좋다.

그래야 눈에 보이는 효과적 성장이 가능하다고 한다.

## 이번주 인사이트 모음집

## 나의 현재 테스트 관련 지식 상태는?

- 변화에 강한 코드 작성, 확장성을 고려하는 코드 → 1
- Cypress의 기본 문법과 흐름 →1
- 함수&모듈 분리 → 2
- 작은 기능으로 나누어 테스트하기 → 1
- 테스트의 given, when ,then → 0
- 실패할 수 있는 경우에 대한 예외처리 생각하기 → 1

## Test Tips

1. REQUIREMENT.md를 만들어서 요구사항을 작게 쪼개고

2. 작게 쪼갠것을 실행시키기 위해 필요한 하위 작업들을 모아서 테스트코드를 작성해보자

예를들면 아래와 같다.

```
1. 로또 구입 금액을 입력한다
   - 입력할 Input태그가 있다.
   - 로또 구입 금액을 입력하면 화면에 입력한 금액이 그대로 보여져야한다.
   - 금액은 숫자만 입력할 수 있다.
...
```

## Given, When, Then 개념

검증 할 테스트 케이스를 먼저 생성 한 뒤 준비 실행 과정을 간편한 테스트 코드로 작성해놓고
이를 테스트통과 시키기 위해 테스트를 진행 할 수 있게 해주는 테스트의 단계별 개념이다.

**given → 준비**

```javascript
cy.visit('somewhere');
```

**when → 실행**

```javascript
cy.get('sth').type('1000');
```

**then → 검증**

```javascript
cy.get('sth').should('have.value', '1000');
```

- **따라서 보고싶은 결과를 먼저 작성하고 실행이 되도록 순서를 then → given → when 으로 진행하면 더욱효과적으로 생각할 수 있다.**
- 가능하면 예외처리에 대한 부분을 요구사항을 고려할 때 함께 생각하며 나뉘어 보는것이 에러를 줄이는데 좋다.
- E2E테스트로 진행하다보니 input엘리먼트가 존재하는지 확인버튼이 존재하는 지 등을 기초적으로 테스트하고 넘어가면 좋다 → 프론트의 최종 종착점은 결국 DOM이 움직이는 것이므로
- then을 쓰면서 이 테스트로 뭘 확인해야하는지 의문이 든다면 단위가 크다고 판단되는 것이므로 더 쪼개보면 좋다.

## 참고하면 좋은 것들

[cypress - stub 사용법, Alert 테스트 예제, 이벤트타입](https://365kim.tistory.com/74)

## Tips

- `cy.visit(”../../index.html”)`과 같이 인덱스 파일 실행시켜도 알아서 돌아가게 싸이프레스가 일해준다.

# 3주차

## 코드 리뷰

- 의견을 확실히 전달
  - 완벽히 이해한 경우 > github 의 경우 Resolve 기능을 활용해주면 좀 깔끔해짐
  - 아닌 경우 댓글로 소통 잘해보면 됨
- 특정 리뷰가 있는 코드의 변경 점인 경우 링크를 따와서 링크 넣고 해당 리뷰 반영했다고 말해도 됨

## 개발자

개발자라면 요구사항을 구현해야한다.

- 일정이 빡빡하다
- 품질 수준을 올리기 위해 노력한다
- 기술 혹인 원하는 무언가를 도전하고 싶다.

## 자바스크립트

[https://github.com/qkraudghgh/clean-code-javascript-ko](https://github.com/qkraudghgh/clean-code-javascript-ko)

## 타입스크립트

[clean-code-typescript](https://738.github.io/clean-code-typescript/)

## JS standard

[JavaScript Standard Style](https://standardjs.com/readme-kokr.html)

그 외에 eslint, airbnb guide 등을 보며 클린코드를 작성하는데 굉장히 도움이 된다.

참고로 이러한 룰들이 무조건적인 정답은 아니므로 참고용인걸 꼭 생각해보자.

## 프론트엔드 개발자란?

HTML이란 문서는 브라우저 위에서 돌아가는데

브라우저는 기기들(맥, 아이폰 등..)에서 돌아감

HTML은 웹(Network)를 통해 연결되는 초월한 문자(Hyper Text)로 구성된 구조적 문서(Mark up)로 브라우저 위에서 동작하며 사용자가 다양한 기기에서 다룰 수 있다.

클라이언트와 js코드가 따로 노는데 이의 지향하는 바가 다를 때 함께 동작 할 수 있는 이유는 **이벤트루프** 덕이다.

그놈의 CSR덕분에 많은 HTML규칙이 어겨진다.

HTML은 기본적인 문서이므로 이를 지키는 것은 중요한 일이 된다.

팀버너스리가 통탄할일..

그래서 form tag등과 같이 의미있는 코드를 쓰는 의식적인 연습을 해보자.

## PS

- data-attribute가 왜 생겼는지도 한번 생각해보자.
- nw.js(윈도우XP가 보통) vs Electron
  - Chromium V8엔진을 쓴다
- 알고리즘
  - 프로그래머스 LV2는 신입공채에서는 택도 없음
    - 그래도 이 정도는 되어야 경력 그나마 합견선에 든다.
  - 알고리즘은 나중에 발목잡히고 뒤늦게 공부하기도 힘들고 뒤늦게 해야할때도 후회한다..
  - 특히 해외진출을 꿈꿀때 정말 열심히해야한다
- CS
  - 큰 기업일 수록 중요한데
    - 프론트엔드는 네트워크가 가장 중요하고 OS가 중요한 순인 것 같다.
      - 네트워크는 깊이 있게 알수록 좋다.. HTTP > OSI > …
        - 세상의 수많은 도구들이 추상적이고 우리는 그것들 그저 사용하기만 하면 됨
        - Axios만 알아도 네트워크 통신을 할 수 있으므로
        - 우리가 사용하는 기술의 근간에 어떤 것이 있는지 알아야함
          - 네트워크가 역사에비해 상당히 어렵고 깊고 넓은 영역의 공부임
          - 그래서 적어도 내가 사용했던 지식들에 대해서는 설명할 줄 알아야한다.
      - HTTP, Cache, Protocol, DNS …
      - 그리고 프로젝트에 도배되어 있는 내용(모르면 큰일 남)
        - WebRTC, 웹소켓 등등 프로젝트에는 있는데 물어보니까 대답을 못함 → 어라??..
    - OS
      - 동시성, 동기, 비동기 꼬리 물다가 OS까지 가는 경우가 꽤 있으므로 알아 놓으면 좋음
      - EX) 리덕스사가 → 이터러블, 이터레이터 → 코루틴 → 동시성 → 동기 & 비동기 → 프로세스 → 스레드 → 실행단위..
- 포트폴리오 꿀팁 → 작업물 꾸러미임
  포트폴리오가 뭔지 정의하는 것 부터 중요하다.
  개발자에게 무언가 작업물들을 담는 꾸러미들은 바로 깃헙이다!
  깃헙이 개발자들을 위한 SNS라고 생각하고 타인이 봤을 때 나는 매력적으로 어필되는지 생각해보자.
  - 경력이 쌓일수록 대충
  - 경력이 짧을수록 자세히
    포트폴리오가 필요한가?
  - 현업에 깃헙 잔디 5년내내 없는 어마어마한 괴물 많다
  - 포트폴리오와 실력이 동등한 관계가 아님
  - 유명한 회사는 어차피 실력자를 걸러낼만한 프로세스가 충분
  - 그런사람이 되면 된다
- 과제
  - 요구사항을 100프로 지키자
    - 불필요하게 추가구현하거나 버그덩어리인 경우가 많으므로 이것만 피해도 된다
  - 어떤 회사는 과제를 면접에서 리팩토링 시키는 경우도 있다고 함

## 리뷰 팁

- 프리티어와 eslint의 확장자도 맞춰주는 것이 좋다
- prefix를 잘 지키는지 확인하는 편
- 유틸에는 서비스코드가(도메인이)묻은 코드가 있는지 보는편
- 파일명 단수 복수도 확인
- 렌더링을 하는 방법 확인
- 생성자를 활용하는 방법

# 4주차

로또 주말안으로 끝내자! 그리고 다음주 목요일 전까지 step3과제로 넘어가서 리뷰 한번 받자

## 로또 미션 공통 피드백

## 네이밍에서 동사가 의미하는 것

```java
onModalShow()
onShowModal()
onGenetateGamesBy()
makeGames()
```

와 같이 동사가 들어가면 함수

By와 같은 접두사는 인자로 무엇인가를 한다

on은 핸들러를 의미하는 암묵적인 의미가 서로 공유되고 있기에 그걸 지켜보면 좋을 듯하다

## 의미 있는 html태그를 사용해보자

## 휴먼에러를 발생시키는 요인을 줄여 보자

- case문이 있을 때 케이스별 텍스트를 잘 활용해야 하므로 그걸 조심해야함
- 상수 관리 시 문자 관리 타입이 여러가지 혼재되는 경우가 있음
  - 파스칼, 스네이크 등등..
  - 상수에서 스네이크 케이스로 쓸 때 재할당하지 말라는 강력한 의미를 위해
  - 파스칼케이스(InputMinInsufficient)는 클래스명, 컴포넌트명, 생성자 함수임을 의미함.
  - 더글라스 크락포드(How javascript works)
    - 얘가 생성자함수로 클래스 만들자고 제안해서 이런 패턴 만듦
- 결론은 상수 관리를 나만의 근거가 확실히 있고 이를 뒷받침할만한 관례와 암묵적 규칙을 가지고 있으면 좋다.
- 잘 정리할 수 있으면 객체로서 잘 관리하는 것도 좋다

## parseInt

parseInt 를 쓸 때 몇진수인지 선언해놓지 않으면 Radix문제가 생길 수 있음(몇진수인지 기재해놓자)

## 성급한 최적화를 하지 말자

1. 요구사항 빨리 만들어서 안전한 코드를 만든 뒤
2. 최적화를 해보자
3. 그런데 가끔은 한계를 넘어선 구현단계부터 성급한 최적화를 연습해서 실력을 늘려보자

## 숫자

숫자를 관리할 때 Numeric Seperator 를 활용하자

## 설정(Prettier, eslint)

설정 시 기본세팅을 최대한 따르고 필요한 부분만 커스터마이징 해서 생태계를 따라가는 방식도 괜찮다

평소에 기본 값을 어느정도 봐 놓는다면 설정을 적어줄때 기본값을 초대한 활용할 수 있게 된다.

## 주석

주석을 의미있게 사용해보자!

## N회 렌더링

프론트엔드 개발자는 사용자의 리소스를 먹는 개발자이고 서버개발자는 서버의 리소스를 먹는 개발자이다.

그래서 N회 렌더링을 최대한 피하는 방식으로 반복문안에서의 렌더를 피해야 한다. 어떤방식을 통해서든 무조건 지우자.

## 유틸코드

유틸코드는 어디까지가 유틸인가 => 에러코드도 유틸로서 해결해보자!

## 도메인

도메인에 종속된 역할은 컨트롤러의 네이밍을 제대로 하여 도메인에 종속되게 만들어 주자

base class ⇒ derived class를 만드는 느낌

```java
//base class
class Controller {};

//derived class
class LottoController extends Controller {
	...
};
```

## 사용자를 위한 에러처리 고민하기

console.error만을 사용하는 것이 아니라 UX에서 발생하는 에러가 생기는 경우 사용자를 위한 에러처리가 필요함.

## 프라이빗 메서드를 사용하고 싶으면

```java
_function --> #privateMethod

```

이제 js가 지원해주면서 저걸 사용하자

## 네이밍 일관성을 확인하기

유행하거나 인기있는 네이밍보다 근거와 이유가 확실한 네이밍이 제일 중요하다.

그러므로 일관성을 지키려 노력하자.

## 프로토타입 접근은 지양하기

기존 메서드를 덮어 쓸 수 있기 떄문이다.

JS는 몽키페칭언어로 사용자가 언어를 커스터마이징 하는게 되어버려서 그걸 막기 위해 프로토타입 체이닝을 막아 쓰면 좋다.

이를 방지하려고 hasOwnProperty → hasOwn 으로 새로운 메서드가 나왔음

## data set attribute 남용하지 않기

그냥 돔에 이상한 네이밍 만들어서 넣어도 되는데 data attribute를 이용하는 이유는

왜 지양하면 좋냐고 주장하나면

개발을 하면 상태관리하는게 DOM에다 쉽게 넣어서 쉽게 꺼낼 수 있어서 편함

**data-attribute를 스토어처럼 사용하는경우가 생겨버림 → 이게 정말 최악의 상황이다.**

그래서 data-attribute는 근거가 있는경우에 사용하면 좋다.

그래서 Html은 문서이므로 이 문서를 보존하면서 구현을 하는 것이 아주 중요한 부분이다.

그래서 사용을 할때도 어떻게 사용하는지에 대한 **근거**를 가지는 것이 아주 중요하다.

문서의 상태는 넣으면 괜찮다, 상태가 아닌경우 넣지 않는 것이 좋다.

## 웹 브라우저 스토리지는 왜 있는감

Persist 데이터라고 하는데 앱과 JS는 다시 재 시동되는데 거기서 중요한 데이터는 이 웹브라우저스토리지를 활용해서

## data-cy와 같은걸 배포할 때 그대로 둔다면

디펜던시가 개발에 있는데 배포된 Html에 있으면 말이 안됨.

그래서 나중에 크롤링으로 털릴 확률이 생긴다 (야놀자 여기어때의 소송케이스도 있다)

## String.raw를 활용하면 템플릿 레터럴이 하이라이팅 된다

[NEXTSTEP](https://edu.nextstep.camp/s/3msbkdKQ/ls/Cxk4TNKn)

# 상태 관리

객체지향 5대원칙

SOLID

폼으로 작성된 내용

⇒ submit

⇒ 제출 시 그 시점의 상태를 활용하는 것

상태를 Pull해오는 영역

사용자가 입력 ⇒ 제출

그제서야 상태를 가져오므로 Pull의 개념

Observer, Closuer는 당연한것..

사용자와 웹앱의 상태를 일치시키기 위해 상태를 계속 pull이아닌 push하여 상태를 계속 업데이트 하는지 확인해 봐야한다.

결론은 제어컴포넌트를 통해 상태를 push하고 있는가를 확인해야한다. 항상 상태가 pull, push 둘 중 어느 방향인지 확인해봐야한다.

- 상태를 push할 수록 힘듦
- pull 할수록 사용자가 힘듦 (사용자의 상태 즉 html의 상태를 가져오는 방법)

결국 사용자가 보는 상태는 Html의 상태이다.

이 서비스는 얼마나 상태를 유효하게 관리해야 하는가, 앱메모리의 상태, 사용자에게 보여지는 상태, html의 상태 등을 함께 고려해야함..

js에서 웹 구현 시 상태가 필요한 이유는 http는 상태를 저장하지 않기 때문이고 웹 스토리지에서 모든 상태를 저장할 수 없기 때문에 이를 계속 저장 및 활용하는 것을 계속 상기하고 어떤방식(push, pull)으로 상태를 관리하고 있는지를 생각하며 코드를 치는 것 도 중요하다.

# 5주차

## 클로저(Closure)

직역하면 Closure는 '함수와 그 함수가 선언될 당시의 Lexical Environment의 상호관계에 따른 현상' 이라고 볼 수 있습니다. 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정합니다. 이를 Lexical Scope(정적 스코프) 라고 합니다. 즉 클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이라고 볼 수 있습니다.

```
const outer = function() {
  let a = 1
  const inner = function() {
    console.log(++a)
  }
  inner()
}

outer()

```

## Closure와 메모리 관리

클로저는 필요에 의해 의도적으로 함수의 지역변수의 메모리를 기억하고 있습니다. 그래서 그 필요성이 사라진 시점에는 더는 메모리를 차지하지 않게 않게 해주어야 하는데요. 참조 카운트를 0으로 만들면 언젠가 GC(Garbage Collector)가 수거해갈 것이고, 이때 해당 지역변수가 차지하고 있던 메모리가 회수됩니다. 참조 카운트를 0으로 만드는 방법은 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 됩니다.

## Event Loop

자바스크립트의 특징 중 하나는 싱글 스레드로 동작하는 것입니다. 싱글 스레드 방식은 한 번에 하나의 task만 처리할 수 있는 것을 의미하는데요. 하지만 브라우저가 동작하는 것을 보면 많은 task가 동시에 처리되는 것처럼 느껴집니다. 예를 들어 html 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링 하기도 합니다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프입니다.

이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나입니다.

## setTimeout

setTimeout 함수는 두 번째 인수로 전달받은 시간(ms, 1/1000초)으로 단 한 번 동작하는 타이머를 생성합니다. 이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출됩니다. 즉, setTimeout 함수의 콜백 함수는 두 번째 인수로 전달받은 시간 이후 단 한 번 실행되도록 호출 스케줄링됩니다.

## RequestAnimationFrame

이 함수는 setInterval() 함수에서 언제 호출할지 설정하는 것과는 달리 브라우저에서 다음 repaint가 일어날 때 콜백이 호출되도록 설정합니다.

setInterval과 RequestAnimationFrame의 차이점은 브라우저에서 여러 탭을 띄워놓고 있을 때 현재 웹페이지가 비활성화되어있으면 setInterval 함수는 백그라운드에서 호출되는 순간마다 계속 실행되지만 RequestAnimationFrame 함수는 화면에 repaint가 일어날 때 호출되므로 백그라운드에서 호출되지 않고 대기한다는 것입니다.

특정 웹페이지에 들어갔다가 백그라운드에 켜놓으면 이유 없이 CPU와 전력을 소모하므로 개발자 관점에서는 큰 차이가 없으나, 사용자 관점에서는 RequestAnimationFrame을 사용하는 것이 좋습니다

## 네이밍도 계층이다

```
class Model {
  #carName = "";

  get carName() {
    // some code
  }

  set carName(carName) {
    // some code
  }
}

```

## 서비스(도메인) 레이어 구분하기

```
// src/js/service/racingCar.js
export const wait = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};
```
