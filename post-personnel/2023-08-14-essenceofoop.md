---
slug: 2023-08-14-essence-of-oop
title: Book comment - 객체지향의 사실과 오해
summary: 역할, 책임, 협력 관점에서 본 객체지향
author: Sanghun lee
date: 2023-08-14 11:33:00 +0800
categories: [OOP]
folder: [post-personnel]
tags: [OOP]
math: true
mermaid: true
image:
  src: '../static/images/posts/concepts-oop.png'
  height: 585
---

# 작성 이유 ?

성장이 더뎌진 것 같아 기본적으로 추천되는 다양한 개념들의 책을 읽어보려한다.

3년차에 이제서야 개발 관련된 제대로된 책들(패턴, 프로그래밍 기법 관련)을 읽어보는것이 좀 아쉽긴하지만.. 나름 CS, 알고리즘, 라이브러리의 근본을 파보기 등 많은 시도를 해보았다고 생각한다. 그 와중에 실제 업무에 조금 더 깔끔하게 가독성좋은 코드를 어떻게 짤까에 대한 고민을 많이하고 있었기에 이런 책들을 읽어보고 리뷰를 남겨보려한다!

첫번째로 읽어볼 책은 GoF의 디자인패턴을 읽어보려 하였으나 OOP에 대해 심도있는 `독서` 는 따로 해보지 않아 이를 읽어보고 간단하게 인상깊은 부분들만을 일부분 발췌하여 코멘트로 남겨 이 책을 읽어보시지 않은 분들은 간단한 책의 느낌을 받으실 수 있도록, 읽으셨던 분들은 회고 할 수 있는 글이 되면 좋겠다.

---

# 서론 ~ 1. 협력하는 객체들의 공동체 [2023/08/14]

## 서론

- 객체지향으로 향하는 첫걸음은 클래스가 아닌 객체를 바라보는 것에서부터 시작한다.
- 두번째 걸음은 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보는 것.
- 세번째 걸음을 내딛을 수 있을지에 대한 여부는 협력에 참여하는 객체들에 얼마나 적절한 역할과 책임을 부여할 수 있느냐에 따라 달려있다.
- 마지막 걸음은 이 개념들을 내가 사용하는 프로그래밍언어에 흐트러짐없이 담아낼 수 있는 기술을 익히는 것이라고 한다.
- 소프트웨어 시스템이 해결하려고 하는 실재는 잘해봐야 먼 친척밖에 되지 않는다 - Bertrand Meyer (OOP를 바라볼 때 실세계의 모방이라는 개념을 차용하는 것이 비현실적이라는 것을 우회적으로 말함.)

## 협력하는 사람들

- `역할, 책임, 협력은 우리가 삶을 영위하기 위해 다른사람과 접촉하는 모든 곳에 존재한다.`
- 협력의 성공은 특정한 역할을 맡은 각 개인이 얼마나 요청을 성실히 이행하는가에 달려있다.
- 역할은 어떤 협력에 참여하는 특정 개인이 협력안에서 차지하는 책임이나 의무를 의미한다.
  - 특정한 역할은 특정한 책임을 암시한다.
- 역할과 책임은 협력이 원활하게 진행되는 데 필요한 핵심적인 구성요소이다.

- 여러사람이 동일한 역할을 수행할 수 있다
  - 해당 역할을 수행하는 사람이 동일한 책임을 성실히 이행한다면 문제가 없다
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
  - 동일한 요청에 대해 서로 다른방식으로 응답할 수 있는 능력을 다형성(polymorphism)이라한다
- 한 사람이 동시에 여러 역할을 수행할 수 있다.
  - 한사람이 동시에 캐시어랑 바리스타라는 역할을 수행할 수도 있다.

## 역할, 책임, 협력

- 협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것이다.
- 책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다.
- 객체의 역할은 사람의 역할과 유사하게 다음과 같은 특징을 가진다

  - 여러 객체가 동일한 역할을 수행할 수 있다.
  - 역할은 대체 가능성을 의미한다.
  - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
  - 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

- 대체 가능한 역할과 책임은 객체지향 패러다임의 중요한 기반을 제공하는 다형성과도 깊이 연관되어 있다.

## 협력속에 사는 객체

- 객체지향 애플리케이션의 아름다움을 결정하는 것이 협력이라면 협력이 얼마나 조화를 이루는지를 결정하는 것은 객체다. 결국, 협력의 품질을 결정하는 것은 객체의 품질이다.

  - 객체는 충분히 `협력적`이어야한다.
  - 객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다. (어떤 방식으로 응답할지는 객체 스스로 판단하고 결정한다.)
  - 객체가 충분히 `자율적`이어야 한다.
  - 객체지향 설계의 묘미는 다른객체와 조화롭게 협력할 수 있을만큼 충분히 개방적인 동시에 협력에 참여하는 방법을 스스로 결정할 수 있을만큼 충분히 자율적인 객체들의 공동체를 설계하는데에 있다.

- 객체는 행동을 위해 필요한 상태를 포함하고 있는 동시에 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다. 따라서 객체는 상태화 행위를 하나의 단위로 묶는 자율적인 존재이다.
- 과거의 전통적 개발방법은 데이터와 프로세스를 엄격하게 구분한다. 이에 반해 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다.

- 객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른객체로부터 메시지를 수신한다. 따라서, 객체지향의 세계에서 협력은 메시지를 전송하는 객체와 수신하는 객체 사이의 관계로 구성된다.

- 객체가 수신된 메시지를 처리하는 방법을 메서드라고 부른다.
- 외부의 요청이 무엇인지를 표현하는 `메시지`와 요청을 처리하기 위한 구체적인 방법인 `메서드`를 분리하는 것은 `객체의 자율성`을 높이는 핵심 메커니즘이다. 이것은 `캡슐화`라는 개념과도 깊이 관련되어 있다.

## 객체 지향의 본질

- 객체 지향이란, 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용하여 시스템을 분할하는 방법이다.
- 자율적인 객체란 `상태`와 `행위`를 함께 지니며 스스로 자기자신을 책임지는 객체를 의미한다.
- 각 객체는 협력내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 `자율적` 으로 선택한다.

- 한다리를 건너면서 조금씩 부풀려지는 에스키모인들의 일화처럼 클래스의 중요성은 프로그래밍 언어라는 다리를 건너면서 조금씩 부풀려졌다.
- 애플리케이션을 협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도로 보는 관점은 유연하고 확장가능한 애플리케이션의 구축을 방해한다.

- 클래스는 객체지향 세계의 도시전설이다.
- 클래스는협력에 참여하는 객체를 만드는데 필요한 구현 메커니즘일뿐이다.
- 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다.

# 2. 이상한 나라의 객체 [2023/08/15]

## 객체지향과 인지 능력

- 객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다.
- 실행중인 객체지향 애플리케이션의 내부를 들여다 볼 수 이다면 겉으로는 우리가 알고 있는 세계와 유사해 보이지만 본질적으로는 매우 이질적인 모습을 지닌 세계와 마주치게 될 것이다.

## 객체, 그리고 이상한나라

- 앨리스의 상태를 결정하는 것은 행동이지만 행동의 결과를 결정하는 것은 상태다.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
  - 행동의 순서가 결과에 영향을 미친다.

## 객체, 그리고 소프트웨어 나라

- 객체란 식별하는한 개체 또는 사물이다.
- 객체는 구별가능한 식별자(Identity), 특별적인 행동(Behavior), 변경가능한 상태(State)를 가진다.
- 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

### 상태

- 인간은 행동의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안했다.
- 상태를 이용하면 과거의 모든 행동이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.
- 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동방식을 이해할 수 있다.
- 상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다.

#### 상태와 프로퍼티

- 모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있다.
- 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(Property)라고한다.
  - 앨리스의 경우 키, 위치, 음료가 해당되겠다.
- 일반적으로 `프로퍼티`는 변경되지 않기에 `정적`이다. `프로퍼티의 값`은 시간이 흐름에 따라 변경되기 때문에 `동적`이다
- 객체와 객체사이의 의미있는 연결을 `링크`라고한다. 링크가 존재해야만 요청을 보내고 받을 수 있다.

  - 링크는 객체가 다른 객체를 참조할 수 있다는 것을 의미하며, 이것은 일반적으로 한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현된다.

- 객체를 구성하는 단순한 값은 속성(attribute)이라고 한다.

- 객체의 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두가지 종류의 조합으로 표현할 수 있다.

  - 정확하게 말하면 프로퍼티는 속성과 연관관계의 두가지 종류로 구분된다. 연관관계는 정적인 관계를 의미하며, 링크는 연관관계의 인스턴스이다. (???)

- `상태`는 특정시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

- 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다.

### 행동

#### 상태와 행동

- 객체의 상태를 변경하는 것은 객체의 자발적인 행동뿐이다.

- 객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 부수효과를 초래한다는 것을 의미한다.
- 객체의 행동은 상태에 영향을 받는다, 객체의 행동은 상태를 변경시킨다.
- 상호작용이 현재의 상태에 어떤방식으로 의존하는가
- 상호작용이 어떻게 현재의 상태를 변경시키는가

- 객체가 다른객체와 협력하는 유일한 방법은 다른객체에게 요청을 보내는 것이다.

#### 협력과 행동

- 객체가 다른객체와 메시지를 통해서만 의사소통할 수 있다는 것을 기억하라
- 객체가 어떤행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지다.
- 행동이란 외부의 요청또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른객체에게 메시지를 전달 할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야한다.

#### 상태 캡슐화

- 객체는 상태를 캡슐안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.
- 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 스스로 결정한다.
- 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다.
- 상태를 잘 정의된 행동집합뒤로 캡슐화 하는 것은, 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다. 이것이 상태를 캡슐화 해야하는 이유다.

### 식별자

- 모든 객체가 식별자를 가진다는 것은 반대로 객체가 아닌 단순한 값은 식별자를 가지지 않는다는 것을 의미한다.
- `값은 숫자,문자열 등과 같이 변하지 않는 양을 모델링`한다.
- 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다.

  - 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)이라고 한다.
  - 상태를 이용해 동등성을 판단할 수 있는 이유는 `값의 상태`가 변하지 않기 때문이다.

- 값은 오직 상태만을 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위한 별도의 식별자를 필요로 하지 않는다.

- 객체 역시 사람과 유사하게 상태와 무관하게 두객체를 동일하거나 다르다고 판단할 수 있는 프로퍼티를 가진다. 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(identical)이라고 한다.

- 식별자란 어떤 객체를 다른객체와 구분하는데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
- 참조 객체(reference object), 또는 엔티티(entity)는 식별자를 지닌 전통적인 의미의 객체를 가리키는 용어다. 값 객체(value object)는 식별자를 가지지 않는 값을 가리키는 용어다.

### 요약!

- 객체는 상태를 가지며 상태는 변경이 가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
  - 행동의 순서가 실행결과에 영향을 미친다.
- 객체는 어떤상태에 있더라도 유일하게 식별 가능하다.

## 기계로서의 객체 [2023/08/16]

- 객체의 상태를 조회하는 작업을 쿼리(Query)라고 한다.
- 객체의 상태를 변경하는 작업을 명령(Command)라고 한다.

## 행동이 상태를 결정한다.

- 안타깝게도 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜영향을 끼친다.
- 상태를 먼저결정할 경우 캡슐화가 저해된다.

  - 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화 되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.

- 협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕모근 상태가 아니라 행동에 초점을 맞추는 것이다.

- 책임 주도 설계(Responsibility- Driven Design, RDD)는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.

- 행동이 상태를 결정한다.

## 은유와 객체

- 추상화란 실제의 사물에서 자신이 원하는 특성만 취하고 필요없는 부분을 추려 핵심만 표현하는 행위를 말한다.
- 그러나 안타깝게도 객체지향 세계는 현실세계의 단순한 모방이 아니다.

  - 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다.

- 오히려 객체지향 세계의 거리는 현실속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다.

- 현실세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 `은유(Metaphor)`이다.
- 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다.

- 여러분이 창조한 객체의 특성을 상기시킬 수 있다면 현실속의 객체의 이름을 이용해 객체를 묘사해라. 그렇지 않다면 깔끔하게 현실을 무시하고 자유롭게 여러분만의 새로운 세계를 창조하기 바란다.

# 3. 타입과 추상화

## 객체지향과 추상화

- 추상화의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다.

```markdown
- 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
  - 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다
  - 첫번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것.
  - 두번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거함으로써 단순하게 만드는 것이다.

모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화 하는것이다.
```

- 공통점을 기반으로 객체들을 묶기위한 그릇을 개념(concept)이라고 한다. 개념이란 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻한다.
- 개념을 이용하면 객체를 여러 그룹으로 분류(classification)할 수 있다.
- 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 인스턴스(instance)라고 한다.

```markdown
객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용되었을 때 객체를 개념의 인스턴스라고 한다.
```

- 일반적으로 객체의 분류장치로서 개념을 이야기할 때는 아래의 세가지 관점을 함께 언급한다.

  - 심볼(Symbol): 개념을 가리키는 간단한 이름이나 명칭
  - 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
  - 외연(extension): 개념에 속하는 모든 객체의 집합(set)

- 개념이 심볼, 내연, 외연으로 구성되어 있다는 사실 보다는 개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요하다.
  개념을 이용해 공통점을 가진 객체들을 분류할 수 있다는 아이디어는 객체지향 패러다임이 복잡성을 극복하는데 사용하는 가장 기본적인 인지 수단이기 때문이다.

- 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을때 우리는 그객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

- 추상화를 사용함으로써 우리는 극도로 복잡한 이 세상을 그나마 제어 가능한 수준으로 단순화 할 수 있는 것이다.

### 타입

- 타입의 정의는 개념의 정의와 완전히 동일하다.
- 타입은 개념과 동일하다. 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체집합의 일원이 된다.
- 안타깝게도 타입이 근본적으로 개념과 동일하다고 하더라도 일단 컴퓨터 내부로 들어오는 순간 좀 더 기계적인 의미로 윤색될 수 밖에 없다.

- 타입 시스템의 목적은 메모리안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.
- 일반적으로 데이터를 이용해 수행할 수 있는 작업을 연산자(Operator)라고 한다.
- 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
  - 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다는 점이다.
- 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.

```markdown
데이터 타입은 메모리안에 저장된 데이터의 종류를 분류하는데 사용하는 메모리 집합에 관한 메타데이터이다.

데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행 될 수 있는지를 결정한다.
```

### 객체와 타입

- 애플리케이션 내부에 살고 있는 모든 객체의 상태를 모으면 결국 애플리케이션에서 관리해야하는 전체 데이터를 표현할 수 있게 된다.
- 다시 한번 강조하지만 객체에서 중요한 것은 객체의 행동이다.
- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
  - 어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.
- 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.

### 행동이 우선이다

- 결론적으로 객체의 타입을 결정하는 것은 객체의 행동뿐이다. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 미치지 않는다.

- 동일한 타입에 속한 객체는 내부의 데이터 표현방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다.
  - 다만 내부 표현방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수 밖에 없다.
  - 이것은 **다형성** 에 의미를 부여한다.
- **다형성**이란 동일한 요청에 대해 서로 다른방식으로 응답할 수 있는 능력을 뜻한다.
- 결과 적으로 다형적인 객체들은 동일한 타입(또는 타입계층)에 속하게 된다.

- 데이터의 내부 표현방식과 무관하게 행동만이 고려대상이라는 사실은 외부에 데이터를 감춰야한다는 것을 의미한다.

  - 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야한다.
  - 이 원칙을 흔히 *캡슐화*라고 한다.

- 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 이것은 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

### 일반화/특수환 관계

- 두 타입간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야하고 반대로 한 타입은 다른타입보다 더 일반적으로 행동해야 한다.

- 일반적인 타입은 특수한 타입보다 더 적은수의 행동을 가지고 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가진다.

- 일반화/특수 화 관계에서 일반적인 타입은 특수한 타입보다 더 적은수의 행동을 가지지만 더 큰크기의 외연집합을 가진다. 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가지지만 더 적은 크기의 외연 집합을 가진다.

### 슈퍼타입과 서브타입

- 일반적인 타입을 슈퍼타입(Supertype) 특수한 타입을 서브타입(Subtype)이라고 한다.
- 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야한다.

## 정적모델

- 타입을 사용하는 이유는 인간의 인지능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.

- 타입은 추상화다. 타입을 이용하면 객체의 동적인 특성을 추상화 할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.

### 동적모델과 정적 모델

- 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐를 객체의 스냅샷(snapshot)이라고 한다.
- 스냅샷처럼 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것을 동적모델(dynamic model)이라고 한다.

- 객체가 가질 수 잇는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것을 타입모델(type diagram)이라고 한다.
  - 이 모델은 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현할기 때문에 정적모델(static model)이라고도 한다.

### 클래스

- 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.

  - 타입은 객체를 분류하기 위해 사용하는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러가지 구현 메커니즘중 하나일 뿐이다.
  - 실제로 자바스크립트와 같은 프로토타입 기반의 언어에는 클래스가 존재하지 않는다(프로토타입을 잘 조합해서 Syntax sugar로 만들어놓은 것이 있을뿐이다.)

- 클래스와 타입을 구분하는 것은 설계를 유연하게 유지하기 위한 바탕이 된다.
  - 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이라는 사실만을 기억하기 바란다.
  - 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한가지 방법이 클래스라는 사실을 아는 것만으로도 충분하다.

# 4. 역할, 책임, 협력
