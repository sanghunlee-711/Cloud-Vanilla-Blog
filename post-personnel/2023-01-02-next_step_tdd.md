---
slug: 2023-01-03-next-step-tdd
title: 넥스트스텝 스터디 참여후기(1~8주차) -- 작성 중
summary: TDD, 클린코드에 조금 더 가까이!
author: Sanghun lee
date: 2023-01-03 11:33:00 +0800
categories: [TDD, Javascript, CleanCode]
folder: [post-personnel]
tags: [TDD]
math: true
mermaid: true
image:
  src: '../static/images/posts/next-step-tdd/next-step.png'
  height: 585
---

# 참가 이유 ?

프로그래머스 스터디 참가 이후, JS로 간단한 웹은 간단한 모듈화와 상태관리를 통해 만들 수 있게 되었다.

하지만 클린한 코드를 적용하거나, 테스트를 어느정도하여 안전한 상태로서의 개발은 여전히 미비했다.

리뷰를 이것저것 찾아보니 참가자들은 다양한 패턴으로의 도전, TDD 적용의 트레이닝, 클린코드의 체득 등을 경험하였다고 하여 망설임 없이 참가하였고, 굉장히 만족스러운 스터디 경험이었다.

---

# 1주차

1주차에는 간단하게 TDD와 관련된 기본 지식 및 어떠한 점을 우리가 유념해가며 접근하면 좋을지에 대한 설명이 이뤄졌다.

## <span style="color: var(--basic-gray)"> TDD란? </span>

**TDD의 핵심은 피드백을 받는것** 이고 실패하는 테스트를 먼저 만들고 그 테스트를 통과하기위해 코드를 짜는 개발 방법이라고 한줄로 요약할 수 있게 되었다.

그리고 아래와 같은 내용들이 기억에 남아 메모하게 되었다.

- 개발방식 이전에 사고방식 테스트를 먼저 만들고 접근하는 것에 대한 사고방식을 강조했다.
- 제대로 동작하는지 빠르게 피드백을 받기위한 사고방식이다.
- 결정과 피드백 사이의 갭에 대한 인식, 더 나아가 결정과 피드백 사이의 갭을 조절하기 위한 테크닉이다.
- 결국은 내 결정이 잘 동작하는지 빠르게 피드백을 얻는것이 중요한 사고 방식이다.
- 따라서 테스트 코드는 의도치 않은 유용한 부산물이 된다.
- **더 자주 피드백을 받기 위해 작은영역으로 핵심을 포함한 가장 중요한 기능부터 문제를 쪼개서 접근해나가아면 좋음**

## <span style="color: var(--basic-gray)"> TDD는 언제 하는 것이 좋은가? </span>

여러번 구현해봐서 어떻게 해야할지 아는 경우는 굳이 할 필요가 없고(굉장히 동의하는 바이다.) **처음 해봐서 막연한 경우, 요구사항이 변경될 수 있는 경우, 개발중에 코드가 많이 변경될 것 같은 경우**, **내가 개발하고 나서 누가 유지보수 할 지 모르는 경우**, **불확실성이 높은 상황일 수록 더 효과적이게 된다**

## <span style="color: var(--basic-gray)"> 클린코드 </span>

깔끔하고 의미가 전달되는 네이밍은 클린코드의 의무사항(?)중 하나인 것 같다.
그렇지만 의도를 드러내는 네이밍 결과로 바로가는 것은 어렵다.

좀 더 그 의도를 드러내는 **과정**에 **집중해보는 것이 좋다고 한다.**

1.  의도를 드러내고(reveal the intention)
2.  구현은 숨기고 (hide the implementation)
3.  반환타입에 대한 명확한 힌트를 제공한다. (give a clear hint as to the expected return type)

    EX) linearSearchFor → searchFor → includes
    EX) getLinearSearchPosition → getSearchPosition → indexOf

## <span style="color: var(--basic-gray)"> 개인 소감 </span>

이런 자료들을 찾아서 양질의 컨텐츠를 교육해주는것이 대단하다고 생각 되었다.

그래서 어떻게 이런자료들을 알게되고 공부하게 되었는지 여쭤보니 엔지니어링 덕질을 하신다고 한다.

추천하는 엔지니어들은 켄트백, 워드 커닝햄 등 고전이 되는 유명한 엔지니어이다.

이들의 책이나 내용이 공감되는 부분이 있을 때 그 부분들을 분석하고 거기서 파생되는 지식과 자료들을 찾아보며 공부하게 되었다고 한다.

테스트코드를 혼자서 이 자료, 저 자료 혼재해가며 열심히 공부하다가 드디어 개념부터하여 양질의 지식들을 제대로 배울 수 있는 기회가 생긴 것 같아 너무 기뻤다.

여기서 잘 배워서 개인블로그, 프로젝트, 회사에 까지 모든 코드들을 테스트를 도입하여 맘 편히 리팩토링 할 수 있게 되면 좋겠다 😅.

## <span style="color: var(--basic-gray)"> 참고하면 좋은 것 들 </span>

- [워드 커닝햄 변수명 짓기](https://wiki.c2.com/?IntentionRevealingNames)

- [PPT](https://docs.google.com/presentation/d/18c4kP9oWbGvKOeX7hd6Tt9FDSWx0NRomdqxQpeUFeto/edit#slide=id.g11a196697e6_0_119)

## 1주차 온보딩 계산기 미션!

나의 온보딩 계산기 미션 참여기!
[[클린코드 4기 이상훈] 계산기 구현](https://github.com/next-step/js-calculator/pull/144)

---

# 2주차

효율적인 공부방법과 테스트와 관련된 조금 심화된 지식들에 대한 상태 점검이 진행되었고 새로운 과제가 시작 되었다.

로또 번호를 생성하고 유저가 기재하는 로또번호를 통해 얼마만큼의 금액을 획득하는지에 관한 과제 내용이었다.

![2ndweek-review](static/images/posts/next-step-tdd/next-step-lotto-1-while.png)

1단계가 진행되었고 유틸 함수와 관련된 리뷰 요청을 꽤 드렸고 알고리즘 스럽게 만드는 것보다 조금 더 가독성이 좋도록 만드는 방법, 여기서 Reduce, while문, Set 자료형 등을 조금 더 활용하는 방식에 눈이 뜨인것 같다.

아래는 과제와 연관은 되어있으나 조금 더 지식에 가까운 세션 내용을 나름 정리하며 기재한 내용이다.

## 효율적인 공부방법 중 하나

```markdown
- 흰색지대 : 적용하고 무슨 내용인지 안다 (2)
- 회색지대: 들어봤고 알고는 있는데 내가 잘쓰지 못하는 것 같다 (1)
- 검은색지대: 감도 안잡힌다 (0)
```

회색지대에서 흰색지대로 공부를 먼저 진행해보면 좋다.
검은색 지대는 어느정도의 회색지대가 커버된 다음 천천히 회색지대로 만들면 좋은 것 같다는 의견이 있었다.

그래야 눈에 보이는 효과적 성장이 가능하다고 한다.

## 나의 현재 테스트 관련 지식 상태는?

`0` -> `1` -> `2` 순서대로 지식상태가 높은 것을 의미하는데 나의 상태는 아래와 같았다.
테스트를 첫 회사부터 꾸역꾸역 혼자서 독학하며 이것저것 구현을 많이 해보아 분리나 기본 작성법은 알았으나, 정작 개념에 대해 잘 몰랐던 것 같다.

```markdown
- 변화에 강한 코드 작성, 확장성을 고려하는 코드 → 1
- Cypress의 기본 문법과 흐름 →1
- 함수&모듈 분리 → 2
- 작은 기능으로 나누어 테스트하기 → 1
- 테스트의 given, when ,then → 0
- 실패할 수 있는 경우에 대한 예외처리 생각하기 → 1
```

## 테스트 코드 작성 및 진행 팁!

1. REQUIREMENT.md를 만들어서 요구사항을 작게 쪼개고

2. 작게 쪼갠것을 실행시키기 위해 필요한 하위 작업들을 모아서 테스트코드를 작성해보자

예를들면 아래와 같다.

```markdown
1. 로또 구입 금액을 입력한다
   - 입력할 Input태그가 있다.
   - 로또 구입 금액을 입력하면 화면에 입력한 금액이 그대로 보여져야한다.
   - 금액은 숫자만 입력할 수 있다.
     ...
```

```js
describe('로또 사이트 E2E테스트', ()=>{
  context('로또 구입 금액을 입력한다', () => {
    it('입력할 Input태그가 있다.', () => {
      cy.get('.로또입력').should('exist');
    })

    ...
  })

  ...
})

```

## Given, When, Then 개념

검증 할 테스트 케이스를 먼저 생성 한 뒤 준비 실행 과정을 간편한 테스트 코드로 작성해놓고
이를 테스트통과 시키기 위해 테스트를 진행 할 수 있게 해주는 테스트의 단계별 개념이다.

**given → 준비**

```javascript
cy.visit('somewhere');
```

**when → 실행**

```javascript
cy.get('sth').type('1000');
```

**then → 검증**

```javascript
cy.get('sth').should('have.value', '1000');
```

- **따라서 보고싶은 결과를 먼저 작성하고 실행이 되도록 순서를 then → given → when 으로 진행하면 더욱효과적으로 생각할 수 있다.**
- 가능하면 예외처리에 대한 부분을 요구사항을 고려할 때 함께 생각하며 나뉘어 보는것이 에러를 줄이는데 좋다.
- E2E테스트로 진행하다보니 input엘리먼트가 존재하는지 확인버튼이 존재하는 지 등을 기초적으로 테스트하고 넘어가면 좋다 → 프론트의 최종 종착점은 결국 DOM이 움직이는 것이므로
- then을 쓰면서 이 테스트로 뭘 확인해야하는지 의문이 든다면 단위가 크다고 판단되는 것이므로 더 쪼개보면 좋다.

## 참고하면 좋은 것들

[cypress - stub 사용법, Alert 테스트 예제, 이벤트타입](https://365kim.tistory.com/74)

## Tips

- `cy.visit(”../../index.html”)`과 같이 인덱스 파일 실행시켜도 알아서 돌아가게 싸이프레스가 일해준다.

---

# 3주차

로또 2단계 스텝이 시작 되었고 html 첫번째 스텝에서 엘리먼트를 DOM으로 조작하는 경우 `data-attribute`를 활용하곤 했는데 무의미하게 선언되고 사용되는 것 같아 이에 대한 리뷰요청 및 이를 어떻게 관리하면 좋을지에 대한 정보를 부탁드렸다.

![3rdweek-review](static/images/posts/next-step-tdd/next-step-lotto-2-event.png)

또한 이벤트 관리에 있어서 단지 Component내부 클래스의 Wrapper단위에서의 관리가 아닌 더 상위에서 한번에 관리 해보는게 어떨까 하는 생각도 가져.. `Map 자료형` 을 활용해 이를 적용해보려고도 하였다. (다음 프로젝트에서는 관리의 어려움이 보여 이 방식을 취하지 않게 되긴 한다)

세션은 코드리뷰에 대한 소소한 팁들과 프론트 개발자로서의 여러가지 팁을 전수해주셨다. 아래는 세션내용 중 당시 내용중 일부 유 의미하다고 생각하는 것 들을 기재한 것이다.

## 코드 리뷰

리뷰 진행 시 의견을 상호 확실히 전달

- 완벽히 이해한 경우, 만약 github 의 경우 Resolve 기능을 활용해주면 좀 깔끔해짐
- 아닌 경우 댓글로 소통 잘해보면 됨
- 특정 리뷰가 있는 코드의 변경 점인 경우 링크를 따와서 링크 넣고 해당 리뷰 반영했다고 말하면 리뷰어, 리뷰이 모두에게 도움이 됨

## 프론트엔드 개발자란?

개발자라면 요구사항을 구현해야한다.

- 일정이 빡빡하다
- 품질 수준을 올리기 위해 노력한다
- 기술 혹인 원하는 무언가를 도전하고 싶다.

HTML이란 문서는 브라우저 위에서 돌아가는데

브라우저는 기기들(맥, 아이폰 등..)에서 돌아감

HTML은 웹(Network)를 통해 연결되는 초월한 문자(Hyper Text)로 구성된 구조적 문서(Mark up)로 브라우저 위에서 동작하며 사용자가 다양한 기기에서 다룰 수 있다.

클라이언트와 js코드가 따로 노는데 이의 지향하는 바가 다를 때 함께 동작 할 수 있는 이유는 **이벤트루프** 덕이다.

그놈의 CSR덕분에 많은 HTML규칙이 어겨진다.

HTML은 기본적인 문서이므로 이를 지키는 것은 중요한 일이 된다.

팀버너스리가 통탄할일..

그래서 form tag등과 같이 의미있는 코드를 쓰는 의식적인 연습을 해보자.

## PS

- data-attribute가 왜 생겼는지도 한번 생각해보자.
- nw.js(윈도우XP가 보통) vs Electron
  - Chromium V8엔진을 쓴다
- 알고리즘
  - 프로그래머스 LV2는 신입공채에서는 택도 없음
    - 그래도 이 정도는 되어야 경력 그나마 합견선에 든다.
  - 알고리즘은 나중에 발목잡히고 뒤늦게 공부하기도 힘들고 뒤늦게 해야할때도 후회한다..
  - 특히 해외진출을 꿈꿀때 정말 열심히해야한다
- CS
  - 큰 기업일 수록 중요한데
    - 프론트엔드는 네트워크가 가장 중요하고 OS가 중요한 순인 것 같다.
      - 네트워크는 깊이 있게 알수록 좋다.. HTTP > OSI > …
        - 세상의 수많은 도구들이 추상적이고 우리는 그것들 그저 사용하기만 하면 됨
        - Axios만 알아도 네트워크 통신을 할 수 있으므로
        - 우리가 사용하는 기술의 근간에 어떤 것이 있는지 알아야함
          - 네트워크가 역사에비해 상당히 어렵고 깊고 넓은 영역의 공부임
          - 그래서 적어도 내가 사용했던 지식들에 대해서는 설명할 줄 알아야한다.
      - HTTP, Cache, Protocol, DNS …
      - 그리고 프로젝트에 도배되어 있는 내용(모르면 큰일 남)
        - WebRTC, 웹소켓 등등 프로젝트에는 있는데 물어보니까 대답을 못함 → 어라??..
    - OS
      - 동시성, 동기, 비동기 꼬리 물다가 OS까지 가는 경우가 꽤 있으므로 알아 놓으면 좋음
      - EX) 리덕스사가 → 이터러블, 이터레이터 → 코루틴 → 동시성 → 동기 & 비동기 → 프로세스 → 스레드 → 실행단위..
- 포트폴리오 꿀팁 → 작업물 꾸러미임
  포트폴리오가 뭔지 정의하는 것 부터 중요하다.
  개발자에게 무언가 작업물들을 담는 꾸러미들은 바로 깃헙이다!
  깃헙이 개발자들을 위한 SNS라고 생각하고 타인이 봤을 때 나는 매력적으로 어필되는지 생각해보자.
  - 경력이 쌓일수록 대충
  - 경력이 짧을수록 자세히
- 포트폴리오가 필요한가?
  - 현업에 깃헙 잔디 5년내내 없는 어마어마한 괴물 많다
  - 포트폴리오와 실력이 동등한 관계가 아님
  - 유명한 회사는 어차피 실력자를 걸러낼만한 프로세스가 충분
  - 그런사람이 되면 된다
- 과제
  - 요구사항을 100프로 지키자
    - 불필요하게 추가구현하거나 버그덩어리인 경우가 많으므로 이것만 피해도 된다
  - 어떤 회사는 과제를 면접에서 리팩토링 시키는 경우도 있다고 함

## 코드 리뷰 진행 시 팁

- 프리티어와 eslint의 확장자도 맞춰주는 것이 좋다
- prefix를 잘 지키는지 확인하는 편
- 유틸에는 서비스코드가(도메인이)묻은 코드가 있는지 보는편
- 파일명 단수 복수도 확인
- 렌더링을 하는 방법 확인
- 생성자를 활용하는 방법

## 클린코드, Standard 자료

- [clean-code-javascript-ko](https://github.com/qkraudghgh/clean-code-javascript-ko)
- [clean-code-typescript](https://738.github.io/clean-code-typescript/)
- [JavaScript Standard Style](https://standardjs.com/readme-kokr.html)

그 외에 eslint, airbnb guide 등을 보며 클린코드를 작성하는데 굉장히 도움이 된다.

참고로 이러한 룰들이 무조건적인 정답은 아니므로 참고용인걸 꼭 생각해보자.

---

# 4주차

로또 미션을 주말안으로 끝내는 것이 목표였다. 왜냐하면.. 다음으로 시작되는 경주미션이 따로 있었기 때문이다.

무리라면 무리가 되었으나 아픈 몸을 이끌고 재밌게 한 것에 의의를 둔다. 그래도 적성에 맞는 일인 것 같아 다행이다 ㅋ

주차가 진행 될 수록 과제의 요구사항 + 리뷰를 받으며 보는 관점의 성장으로 PR제출까지 더 딜레이 되는 경우가 꽤 있었는데 만만한 스터디가 아니구나 생각했다.

[코드리뷰](https://github.com/next-step/js-lotto/pull/210)에서 중점적으로 진행한것은 상수의 관리, Element 이름을 통합하여 관리를 용이하게 하기, 이벤트바인딩 주체의 변경, 테스트 코드의 커맨드 관리 등이 있었다.

Github pages를 이용해 간단하게 [js-lotto 배포버전](https://sanghunlee-711.github.io/js-lotto/) 배포도 진행하였다.

![4thweek-review-lotto](static/images/posts/next-step-tdd/next-step-lotto-3-ux.png)

이렇게 관리를 한다고 했음에도 불구하고 UX 개선과 관련된 리뷰를 받았는데 다양한 이벤트와 태그를 적절히 활용하면 오히려 불필요한 코드 작성을 줄이고더 좋은 UX를 제공할 수 있다는 사실을 다시 한번 알게 된 계기인 것 같다.

![4thweek-review-car](static/images/posts/next-step-tdd/next-step-car-1-class.png)

그리고 새로운 미션인 자동차 경주 미션을 동일 주차에 시작하게 되었는데, [황준일님의 블로그](https://junilhwang.github.io/TIL/) 에서 재미있게 봤던 Proxy 객체를 이용한 전역상태관리, Base Class로 컴포넌트를 만들고 이를 확장하는 방식의 개발을 접목하였다.

[해당 리뷰](https://github.com/next-step/js-racingcar/pull/127)에서 리뷰어분은 이런 형태의 과제를 많이 봐와서 불신 및 안타까움의 리뷰를 달아주셨고 이 방식을 벗어나 다양한 것을 시도해보려 하다 오히려 빙빙 돌아 이상한 방식을 적용도 해보게 되었다.

이 과정에서 외부 this를 어떻게 끌어올 수 있을까에 대한 고민도 많이 진행 되며 eval인 것의 이유를 다시한번 상기하게 되고, Base를 두고 확장한다는 것이 마냥 좋은 것이 아님을 다시 한번 깨닫게 되었다.

당시에는 많이 고민하고 치열하게 작성한 리뷰, 코드인 것 같으나 지금 와서 돌아보면 별 것 아닌 것 처럼 보인다. ㅋㅋㅋㅋ.. 그렇다.

주차의 세션에서 미션을 직접적으로 다루지는 않고 보통 강의를 통해 얻어갈 수 있는 팁이나 지식을 전달해주었는데 이번 주차는 Sementic 개념의 심화라고 보면 될 것 같다.

## 네이밍에서 동사가 의미하는 것

```java
onModalShow()
onShowModal()
onGenetateGamesBy()
makeGames()
```

와 같이 동사가 들어가면 함수 By와 같은 접두사는 인자로 무엇인가를 한다.

on은 핸들러를 의미하는 암묵적인 의미가 서로 공유되고 있기에 그걸 지켜보면 좋을 듯하다.

## 휴먼에러를 발생시키는 요인을 줄여 보자

### 상수

상수 관리 시 문자 관리 타입이 여러가지 혼재되는 경우가 있는데(파스칼, 스네이크 등등..) 아래와 같은 의미를 공유하면 좋다.

- 상수에서 스네이크 케이스로 쓸 때 재할당하지 말라는 강력한 의미를 위해
- 파스칼케이스(InputMinInsufficient)는 클래스명, 컴포넌트명, 생성자 함수임을 의미함.
- 더글라스 크락포드(How javascript works)
  - 얘가 생성자함수로 클래스 만들자고 제안해서 이런 패턴 만듦

**결론은 상수 관리를 나만의 근거가 확실히 있고 이를 뒷받침할만한 관례와 암묵적 규칙을 가지고 있으면 좋다.** 또는 잘 정리할 수 있으면 하나의 객체로서 잘 관리하는 것도 좋다

### 숫자

- parseInt 를 쓸 때 몇진수인지 선언해놓지 않으면 Radix문제가 생길 수 있음(몇진수인지 기재해놓자)
- 숫자를 관리할 때 Numeric Seperator 를 활용하자

### 최적화

성급한 최적화를 하지 말자

1. 요구사항 빨리 만들어서 안전한 코드를 만든 뒤
2. 최적화를 해보자
3. 그런데 가끔은 한계를 넘어선 구현단계부터 성급한 최적화를 연습해서 실력을 늘려보자

### 설정(Prettier, eslint)

설정 시 기본세팅을 최대한 따르고 필요한 부분만 커스터마이징 해서 생태계를 따라가는 방식도 괜찮다

평소에 기본 값을 어느정도 봐 놓는다면 설정을 적어줄때 기본값을 초대한 활용할 수 있게 된다.

### N회 렌더링

프론트엔드 개발자는 사용자의 리소스를 먹는 개발자이고 서버개발자는 서버의 리소스를 먹는 개발자이다.

그래서 N회 렌더링을 최대한 피하는 방식으로 반복문안에서의 렌더를 피해야 한다. 어떤방식을 통해서든 무조건 지우자.

### 유틸코드

유틸코드는 어디까지가 유틸인가에 대한 정의를 잘 내리고 에러코드도 유틸 함수로 분리하여 간결하게 관리 및 적용을 해보자!

### 도메인

도메인에 종속된 역할은 컨트롤러의 네이밍을 제대로 하여 도메인에 종속되게 만들어 주자

base class ⇒ derived class를 만드는 느낌

```java
//base class
class Controller {};

//derived class
class LottoController extends Controller {
	...
};
```

### 사용자를 위한 에러처리 고민하기

console.error만을 사용하는 것이 아니라 UX에서 발생하는 에러가 생기는 경우 사용자를 위한 에러처리가 필요함.

### 네이밍 일관성을 확인하기

유행하거나 인기있는 네이밍보다 근거와 이유가 확실한 네이밍이 제일 중요하다.

그러므로 일관성을 지키려 노력하자.

### 프로토타입 접근은 지양하기

기존 메서드를 덮어 쓸 수 있기 떄문이다.

JS는 몽키페칭언어로 사용자가 언어를 커스터마이징 하는게 되어버려서 그걸 막기 위해 프로토타입 체이닝을 막아 쓰면 좋다.

이를 방지하려고 hasOwnProperty → hasOwn 으로 새로운 메서드가 나왔음

### data set attribute 남용하지 않기

그냥 돔에 이상한 네이밍 만들어서 넣어도 되는데 data-attribute를 이용하는 이유는 의미론적 표준 HTML 요소에 추가 정보를 저장할 수 있도록 하기 위한 약속이다.

이의 사용을 지양하는 것이 왜 좋냐고 주장하나면 개발을 하다 보면 상태관리를 하는 방식 중 DOM요소에 쉽게 넣어서 쉽게 꺼낼 수 있는 것이 편한데, 이렇게 활용될 여지가 있는 것이 첫번째 문제이다.

**다시 말하면, data-attribute를 상태 저장소 사용하는경우가 생겨버리는데 이게 정말 최악의 상황이다.**

그래서 data-attribute는 근거가 있는경우에 사용하면 좋다.

html은 문서이므로 이 문서를 보존하면서 구현을 하는 것이 아주 중요한 부분이다.

그래서 사용을 할때도 어떻게 사용하는지에 대한 **근거**를 가지는 것이 아주 중요하다.

`data-index` 나 `data-columns`와 같은 네이밍은 딱히 보안상 중요하지도, 상태를 담고 있지도 않을 내용이나 DOM에서 필요한 경우가 있으면 따로 명시하여 사용하는 것도 좋은 선택지가 될 수도 있다.

하지만, Cypress에서 E2E테스트 작성 시 DOM 선택의 용이성을 위해 `data-cy`와 같은걸 상용 배포할 때, 그대로 둔다면 디펜던시가 개발에 있는데(data-cy가 사용되는건 개발단계 뿐인데) 배포된 Html에 있으면 의미론적으로도 근거적으로도 맞지 않기 때문에 지양하는 것이 좋다.

최악의 경우, 해당 attribute에 중요 정보가 담겨있는 상황이라면, 나중에 크롤링으로 해당 정보가 털릴 확률이 생긴다 (야놀자, 여기어때의 소송케이스도 있다)

### 웹 브라우저 스토리지는 왜 있는감

Persist 데이터라고 하는데 앱과 JS는 다시 재 시동되는데 거기서 중요한 데이터는 이 웹브라우저스토리지를 활용해서 지속을 시킬 수 있기 때문이다.

하지만 보안상으로 노출되면 큰일나는 것들을 넣어놓는 것은 지양하는게 좋다.

# 상태 관리

우선, 객체지향 5대원칙인 SOLID를 잘 지켜보자.

그리고, 상태관리는 크게 Pull, Push상태를 생각해볼 수 있다.

예를 들어, 폼으로 작성된 내용은 제출을 통해 제출 시 그 시점의 상태를 활용할 수 있게 되는데 이때, 상태를 `Pull` 해오는 영역은 사용자가 입력한 값을 제출할 때 이다.

왜냐면 그때서야 상태를 브라우저 메모리로 가져오게 되어 비즈니스로직이 필요하다면 녹여낼 수 있기 때문에 이 시점이 `Pull`이라고 생각하면 쉽다.

이런 관점에서 상태관리를 바라보게 된다면 웹앱의 상태와 사용자의 상태가 일치하지 않는 시점인 `사용자의 타이핑 ~ 제출` 까지의 **공백시점**이 생겨버린다.

따라서 상태관리는 `Push`방식인 브라우저 메모리에서 DOM으로 밀어주는 방식을 채택하는게 조금 더 상태 일치를 위해서는 유용한 방법이 될 수 있다.

하지만 상태를 `Push`하는 방식으로 관리하면 할 수록 개발의 난이도가 상승되게 되고, `Pull`방식이 많이 들어가면 들어갈 수록 사용자가 해야할 일이 많아진다.

결론은 제어컴포넌트를 통해 상태를 push하고 있는가를 확인해야한다. 항상 상태가 `Pull`, `Push` 둘 중 어느 방향인지 확인해봐야한다.

결국 사용자가 보는 상태는 Html의 상태이다.

따라서, 이 서비스는 얼마나 상태를 유효하게 관리해야 하는가, 앱 메모리의 상태, 사용자에게 보여지는 상태, html의 상태 등을 함께 고려해야하며 개발을 진행해야 한다.

JS 에서 웹 구현 시 상태가 필요한 이유는 http는 상태를 저장하지 않기(Stateless Protocol) 때문이고 웹 스토리지에서 모든 상태를 저장할 수 없기 때문이다.

결국 개발자는 이를 지속적인 저장 및 활용하는 것을 상기하고 어떤방식(`Push`, `Pull`)으로 상태를 관리하고 있는지를 생각하며 코드를 치는 것이 중요하다.

## Tips

- String.raw를 활용하면 템플릿 레터럴이 하이라이팅 된다

---

# 5주차

JS의 기본적 활용기법(클로저, setTimeout, Interval, 비동기 처리등..)의 심도 있는 이야기와 이것이 활용된 과제를 진행하였다.

## 클로저(Closure)

직역하면 Closure는 '함수와 그 함수가 선언될 당시의 Lexical Environment의 상호관계에 따른 현상' 이라고 볼 수 있습니다. 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정합니다. 이를 Lexical Scope(정적 스코프) 라고 합니다. 즉 클로저는 어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상이라고 볼 수 있습니다.

```
const outer = function() {
  let a = 1
  const inner = function() {
    console.log(++a)
  }
  inner()
}

outer()

```

## Closure와 메모리 관리

클로저는 필요에 의해 의도적으로 함수의 지역변수의 메모리를 기억하고 있습니다. 그래서 그 필요성이 사라진 시점에는 더는 메모리를 차지하지 않게 않게 해주어야 하는데요. 참조 카운트를 0으로 만들면 언젠가 GC(Garbage Collector)가 수거해갈 것이고, 이때 해당 지역변수가 차지하고 있던 메모리가 회수됩니다. 참조 카운트를 0으로 만드는 방법은 식별자에 참조형이 아닌 기본형 데이터(보통 null이나 undefined)를 할당하면 됩니다.

## Event Loop

자바스크립트의 특징 중 하나는 싱글 스레드로 동작하는 것입니다. 싱글 스레드 방식은 한 번에 하나의 task만 처리할 수 있는 것을 의미하는데요. 하지만 브라우저가 동작하는 것을 보면 많은 task가 동시에 처리되는 것처럼 느껴집니다. 예를 들어 html 요소가 애니메이션 효과를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링 하기도 합니다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프입니다.

이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나입니다.

## setTimeout

setTimeout 함수는 두 번째 인수로 전달받은 시간(ms, 1/1000초)으로 단 한 번 동작하는 타이머를 생성합니다. 이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출됩니다. 즉, setTimeout 함수의 콜백 함수는 두 번째 인수로 전달받은 시간 이후 단 한 번 실행되도록 호출 스케줄링됩니다.

## RequestAnimationFrame

이 함수는 setInterval() 함수에서 언제 호출할지 설정하는 것과는 달리 브라우저에서 다음 repaint가 일어날 때 콜백이 호출되도록 설정합니다.

setInterval과 RequestAnimationFrame의 차이점은 브라우저에서 여러 탭을 띄워놓고 있을 때 현재 웹페이지가 비활성화되어있으면 setInterval 함수는 백그라운드에서 호출되는 순간마다 계속 실행되지만 RequestAnimationFrame 함수는 화면에 repaint가 일어날 때 호출되므로 백그라운드에서 호출되지 않고 대기한다는 것입니다.

특정 웹페이지에 들어갔다가 백그라운드에 켜놓으면 이유 없이 CPU와 전력을 소모하므로 개발자 관점에서는 큰 차이가 없으나, 사용자 관점에서는 RequestAnimationFrame을 사용하는 것이 좋습니다

## 네이밍도 계층이다

```
class Model {
  #carName = "";

  get carName() {
    // some code
  }

  set carName(carName) {
    // some code
  }
}

```

## 서비스(도메인) 레이어 구분하기

```
// src/js/service/racingCar.js
export const wait = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};
```
